# ä»£ç æ”¹åŠ¨æ€»ç»“\n\n## ğŸ“ æ¦‚è¿°\n\nå·²æˆåŠŸå®ç°äº†å¹¶è¡Œæ¨¡å¼IPå»é‡çš„å®Œæ•´è§£å†³æ–¹æ¡ˆã€‚æ”¹åŠ¨åŒ…æ‹¬ï¼š\n- IPçº§åˆ«å»é‡ï¼ˆä¸¤å±‚ï¼‰\n- å†™å…¥å‰è½»é‡çº§éªŒè¯\n- é˜²å¾¡æ€§å»é‡ï¼ˆç¼“å­˜å±‚ï¼‰\n- å¢å¼ºçš„äº‹åéªŒè¯æ—¥å¿—\n\n---\n\n## ğŸ”§ æ”¹åŠ¨è¯¦æƒ…\n\n### æ–‡ä»¶1: upstream/manager_parallel.go\n\n#### æ”¹åŠ¨1.1: å¢å¼º mergeAndDeduplicateRecords() å‡½æ•°\n\n**ä½ç½®**: ç¬¬ ~240 è¡Œ\n\n**æ”¹åŠ¨å‰**:\n```go\nfunc (u *Manager) mergeAndDeduplicateRecords(results []*QueryResult) []dns.RR {\n    recordSet := make(map[string]dns.RR)\n    var mergedRecords []dns.RR\n\n    for _, result := range results {\n        for _, rr := range result.Records {\n            key := rr.String()\n            if _, exists := recordSet[key]; !exists {\n                recordSet[key] = rr\n                mergedRecords = append(mergedRecords, rr)\n            }\n        }\n    }\n\n    return mergedRecords\n}\n```\n\n**æ”¹åŠ¨å**:\n```go\nfunc (u *Manager) mergeAndDeduplicateRecords(results []*QueryResult) []dns.RR {\n    recordSet := make(map[string]dns.RR)\n    ipSet := make(map[string]bool)  // æ–°å¢ï¼šIPçº§åˆ«å»é‡\n    var mergedRecords []dns.RR\n\n    for _, result := range results {\n        for _, rr := range result.Records {\n            key := rr.String()\n            if _, exists := recordSet[key]; !exists {\n                recordSet[key] = rr\n\n                // æ–°å¢ï¼šIPçº§åˆ«å»é‡æ£€æŸ¥\n                shouldAdd := true\n                switch rec := rr.(type) {\n                case *dns.A:\n                    ipStr := rec.A.String()\n                    if ipSet[ipStr] {\n                        shouldAdd = false\n                    } else {\n                        ipSet[ipStr] = true\n                    }\n                case *dns.AAAA:\n                    ipStr := rec.AAAA.String()\n                    if ipSet[ipStr] {\n                        shouldAdd = false\n                    } else {\n                        ipSet[ipStr] = true\n                    }\n                }\n\n                if shouldAdd {\n                    mergedRecords = append(mergedRecords, rr)\n                }\n            }\n        }\n    }\n\n    return mergedRecords\n}\n```\n\n**æ”¹åŠ¨è¯´æ˜**:\n- æ·»åŠ äº†IPçº§åˆ«çš„å»é‡æœºåˆ¶\n- ä½¿ç”¨ipSet mapè®°å½•å·²è§è¿‡çš„IP\n- å¯¹Aå’ŒAAAAè®°å½•éƒ½è¿›è¡ŒIPå»é‡\n- åªæœ‰é€šè¿‡IPå»é‡æ£€æŸ¥çš„è®°å½•æ‰ä¼šè¢«æ·»åŠ \n\n---\n\n#### æ”¹åŠ¨1.2: æ·»åŠ è½»é‡çº§éªŒè¯\n\n**ä½ç½®**: collectRemainingResponses() å‡½æ•°ä¸­ï¼Œç¬¬ ~220 è¡Œ\n\n**æ”¹åŠ¨å‰**:\n```go\n// åˆå¹¶æ‰€æœ‰é€šç”¨è®°å½•ï¼ˆå»é‡ï¼‰\nmergedRecords := u.mergeAndDeduplicateRecords(allSuccessResults)\n\n// é€‰æ‹©æœ€å°çš„TTL(æœ€ä¿å®ˆçš„ç­–ç•¥)\nminTTL := fastResponse.TTL\nfor _, result := range allSuccessResults {\n    if result.TTL < minTTL {\n        minTTL = result.TTL\n    }\n}\n\nlogger.Debugf(\"[collectRemainingResponses] âœ… åå°æ”¶é›†å®Œæˆ: ...\")\n\n// å¦‚æœè®¾ç½®äº†ç¼“å­˜æ›´æ–°å›è°ƒï¼Œåˆ™è°ƒç”¨å®ƒæ¥æ›´æ–°ç¼“å­˜\nif u.cacheUpdateCallback != nil {\n    logger.Debugf(\"[collectRemainingResponses] ğŸ“ è°ƒç”¨ç¼“å­˜æ›´æ–°å›è°ƒ...\")\n    u.cacheUpdateCallback(domain, qtype, mergedRecords, fastResponse.CNAMEs, minTTL)\n}\n```\n\n**æ”¹åŠ¨å**:\n```go\n// åˆå¹¶æ‰€æœ‰é€šç”¨è®°å½•ï¼ˆå»é‡ï¼‰\nmergedRecords := u.mergeAndDeduplicateRecords(allSuccessResults)\n\n// è½»é‡çº§éªŒè¯ (å†™å…¥å‰) - æ–°å¢\nif len(mergedRecords) == 0 {\n    logger.Warnf(\"[collectRemainingResponses] âš ï¸  è­¦å‘Š: å»é‡åæ²¡æœ‰è®°å½•ï¼Œä¸æ›´æ–°ç¼“å­˜\")\n    return\n}\n\n// è®¡ç®—å»é‡ç‡ - æ–°å¢\ntotalRecordsBefore := 0\nfor _, result := range allSuccessResults {\n    totalRecordsBefore += len(result.Records)\n}\ndedupeRate := 0.0\nif totalRecordsBefore > 0 {\n    dedupeRate = float64(totalRecordsBefore-len(mergedRecords)) / float64(totalRecordsBefore) * 100\n}\n\nlogger.Debugf(\"[collectRemainingResponses] å»é‡ç»Ÿè®¡: å»é‡å‰ %d æ¡è®°å½•, å»é‡å %d æ¡è®°å½•, å»é‡ç‡ %.1f%%\",\n    totalRecordsBefore, len(mergedRecords), dedupeRate)\n\n// é€‰æ‹©æœ€å°çš„TTL(æœ€ä¿å®ˆçš„ç­–ç•¥)\nminTTL := fastResponse.TTL\nfor _, result := range allSuccessResults {\n    if result.TTL < minTTL {\n        minTTL = result.TTL\n    }\n}\n\nlogger.Debugf(\"[collectRemainingResponses] âœ… åå°æ”¶é›†å®Œæˆ: ...\")\n\n// é€šè¿‡éªŒè¯åï¼Œè°ƒç”¨ç¼“å­˜æ›´æ–°å›è°ƒ - æ”¹åŠ¨\nif u.cacheUpdateCallback != nil {\n    logger.Debugf(\"[collectRemainingResponses] ğŸ“ è°ƒç”¨ç¼“å­˜æ›´æ–°å›è°ƒ...\")\n    u.cacheUpdateCallback(domain, qtype, mergedRecords, fastResponse.CNAMEs, minTTL)\n}\n```\n\n**æ”¹åŠ¨è¯´æ˜**:\n- æ·»åŠ äº†å†™å…¥å‰éªŒè¯\n- æ£€æŸ¥å»é‡åæ˜¯å¦æœ‰è®°å½•\n- è®¡ç®—å¹¶è®°å½•å»é‡ç‡\n- å¦‚æœéªŒè¯å¤±è´¥ï¼Œä¸è°ƒç”¨ç¼“å­˜æ›´æ–°å›è°ƒ\n\n---\n\n### æ–‡ä»¶2: cache/cache_raw.go\n\n#### æ”¹åŠ¨2.1: å¢å¼º SetRawRecordsWithDNSSEC() å‡½æ•°\n\n**ä½ç½®**: ç¬¬ ~50 è¡Œ\n\n**æ”¹åŠ¨å‰**:\n```go\nfunc (c *Cache) SetRawRecordsWithDNSSEC(domain string, qtype uint16, records []dns.RR, cnames []string, upstreamTTL uint32, authData bool) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    // ä» records ä¸­æå– A/AAAA è®°å½•çš„ IP å­—ç¬¦ä¸²\n    var ips []string\n    for _, r := range records {\n        switch rec := r.(type) {\n        case *dns.A:\n            ips = append(ips, rec.A.String())\n        case *dns.AAAA:\n            ips = append(ips, rec.AAAA.String())\n        }\n    }\n\n    key := cacheKey(domain, qtype)\n    entry := &RawCacheEntry{\n        Records:           records,\n        IPs:               ips,\n        CNAMEs:            cnames,\n        UpstreamTTL:       upstreamTTL,\n        AcquisitionTime:   timeNow(),\n        AuthenticatedData: authData,\n    }\n    c.rawCache.Set(key, entry)\n}\n```\n\n**æ”¹åŠ¨å**:\n```go\nfunc (c *Cache) SetRawRecordsWithDNSSEC(domain string, qtype uint16, records []dns.RR, cnames []string, upstreamTTL uint32, authData bool) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    // ä» records ä¸­æå– A/AAAA è®°å½•çš„ IP å­—ç¬¦ä¸²ï¼ˆå»é‡ï¼‰ - æ”¹åŠ¨\n    ipSet := make(map[string]bool)  // æ–°å¢\n    var ips []string\n    for _, r := range records {\n        switch rec := r.(type) {\n        case *dns.A:\n            ipStr := rec.A.String()  // æ–°å¢\n            if !ipSet[ipStr] {       // æ–°å¢\n                ipSet[ipStr] = true  // æ–°å¢\n                ips = append(ips, ipStr)\n            }\n        case *dns.AAAA:\n            ipStr := rec.AAAA.String()  // æ–°å¢\n            if !ipSet[ipStr] {          // æ–°å¢\n                ipSet[ipStr] = true     // æ–°å¢\n                ips = append(ips, ipStr)\n            }\n        }\n    }\n\n    key := cacheKey(domain, qtype)\n    entry := &RawCacheEntry{\n        Records:           records,\n        IPs:               ips,  // å·²å»é‡\n        CNAMEs:            cnames,\n        UpstreamTTL:       upstreamTTL,\n        AcquisitionTime:   timeNow(),\n        AuthenticatedData: authData,\n    }\n    c.rawCache.Set(key, entry)\n}\n```\n\n**æ”¹åŠ¨è¯´æ˜**:\n- æ·»åŠ äº†é˜²å¾¡æ€§IPå»é‡\n- åœ¨æ´¾ç”ŸIPsæ—¶è¿›è¡Œå»é‡\n- ç¡®ä¿ç¼“å­˜ä¸­çš„IPsåˆ—è¡¨æ²¡æœ‰é‡å¤\n\n---\n\n### æ–‡ä»¶3: dnsserver/server_callbacks.go\n\n#### æ”¹åŠ¨3.1: å¢å¼º setupUpstreamCallback() å‡½æ•°\n\n**ä½ç½®**: ç¬¬ ~20 è¡Œ\n\n**æ”¹åŠ¨å‰**:\n```go\nfunc (s *Server) setupUpstreamCallback(u *upstream.Manager) {\n    u.SetCacheUpdateCallback(func(domain string, qtype uint16, records []dns.RR, cnames []string, ttl uint32) {\n        logger.Debugf(\"[CacheUpdateCallback] æ›´æ–°ç¼“å­˜: ...\")\n\n        var oldIPCount int\n        if oldEntry, exists := s.cache.GetRaw(domain, qtype); exists {\n            oldIPCount = len(oldEntry.IPs)\n        }\n\n        s.cache.SetRawRecords(domain, qtype, records, cnames, ttl)\n\n        var newIPCount int\n        if newEntry, exists := s.cache.GetRaw(domain, qtype); exists {\n            newIPCount = len(newEntry.IPs)\n        }\n\n        if (newIPCount > oldIPCount) && (qtype == dns.TypeA || qtype == dns.TypeAAAA) {\n            logger.Debugf(\"[CacheUpdateCallback] åå°æ”¶é›†åˆ°æ›´å¤šIP (%d -> %d)...\")\n            // é‡æ–°æ’åº\n        } else {\n            logger.Debugf(\"[CacheUpdateCallback] IPæ•°é‡æœªå¢åŠ  (%d)...\")\n        }\n    })\n}\n```\n\n**æ”¹åŠ¨å**:\n```go\nfunc (s *Server) setupUpstreamCallback(u *upstream.Manager) {\n    u.SetCacheUpdateCallback(func(domain string, qtype uint16, records []dns.RR, cnames []string, ttl uint32) {\n        logger.Debugf(\"[CacheUpdateCallback] æ›´æ–°ç¼“å­˜: ...\")\n\n        var oldIPCount int\n        if oldEntry, exists := s.cache.GetRaw(domain, qtype); exists {\n            oldIPCount = len(oldEntry.IPs)\n        }\n\n        s.cache.SetRawRecords(domain, qtype, records, cnames, ttl)\n\n        var newIPCount int\n        if newEntry, exists := s.cache.GetRaw(domain, qtype); exists {\n            newIPCount = len(newEntry.IPs)\n        }\n\n        // äº‹åéªŒè¯ï¼šè®°å½•IPå˜åŒ–å’Œç»Ÿè®¡ä¿¡æ¯ - æ–°å¢\n        if oldIPCount > 0 {\n            ipChangeRate := float64(newIPCount-oldIPCount) / float64(oldIPCount) * 100\n            logger.Debugf(\"[CacheUpdateCallback] IPå˜åŒ–: %d -> %d (å˜åŒ–ç‡: %.1f%%)\",\n                oldIPCount, newIPCount, ipChangeRate)\n        } else {\n            logger.Debugf(\"[CacheUpdateCallback] IPæ•°é‡: %d (æ–°å¢)\", newIPCount)\n        }\n\n        if (newIPCount > oldIPCount) && (qtype == dns.TypeA || qtype == dns.TypeAAAA) {\n            logger.Debugf(\"[CacheUpdateCallback] åå°æ”¶é›†åˆ°æ›´å¤šIP (%d -> %d)...\")\n            // é‡æ–°æ’åº\n        } else {\n            logger.Debugf(\"[CacheUpdateCallback] IPæ•°é‡æœªå¢åŠ  (%d)...\", newIPCount)\n        }\n    })\n}\n```\n\n**æ”¹åŠ¨è¯´æ˜**:\n- æ·»åŠ äº†IPå˜åŒ–ç‡è®¡ç®—\n- åŒºåˆ†æ–°å¢å’Œæ›´æ–°çš„æƒ…å†µ\n- æä¾›æ›´è¯¦ç»†çš„æ—¥å¿—ä¿¡æ¯\n\n---\n\n## ğŸ“Š æ”¹åŠ¨ç»Ÿè®¡\n\n| æ–‡ä»¶ | å‡½æ•° | æ”¹åŠ¨ç±»å‹ | è¡Œæ•° | è¯´æ˜ |\n|------|------|--------|------|------|\n| upstream/manager_parallel.go | mergeAndDeduplicateRecords | å¢å¼º | ~30 | IPçº§åˆ«å»é‡ |\n| upstream/manager_parallel.go | collectRemainingResponses | æ–°å¢ | ~20 | è½»é‡çº§éªŒè¯ |\n| cache/cache_raw.go | SetRawRecordsWithDNSSEC | å¢å¼º | ~15 | é˜²å¾¡æ€§å»é‡ |\n| dnsserver/server_callbacks.go | setupUpstreamCallback | å¢å¼º | ~10 | å¢å¼ºæ—¥å¿— |\n| **æ€»è®¡** | | | **~75** | |\n\n---\n\n## âœ… ç¼–è¯‘éªŒè¯\n\næ‰€æœ‰æ”¹åŠ¨éƒ½å·²é€šè¿‡ç¼–è¯‘æ£€æŸ¥ï¼š\n\n```\nâœ… upstream/manager_parallel.go - æ— é”™è¯¯\nâœ… cache/cache_raw.go - æ— é”™è¯¯\nâœ… dnsserver/server_callbacks.go - æ— é”™è¯¯\n```\n\n---\n\n## ğŸ”„ æµç¨‹å˜åŒ–\n\n### æ”¹åŠ¨å‰\n\n```\nå¹¶å‘æŸ¥è¯¢ â†’ å¿«é€Ÿè¿”å› â†’ åå°å¤„ç†\n                      â”œâ”€ å»é‡ (è®°å½•çº§åˆ«)\n                      â”œâ”€ å†™å…¥ç¼“å­˜\n                      â””â”€ äº‹åéªŒè¯ (IPæ•°é‡æ¯”è¾ƒ)\n```\n\n### æ”¹åŠ¨å\n\n```\nå¹¶å‘æŸ¥è¯¢ â†’ å¿«é€Ÿè¿”å› â†’ åå°å¤„ç†\n                      â”œâ”€ å»é‡ (è®°å½•çº§åˆ« + IPçº§åˆ«) âœ…\n                      â”œâ”€ è½»é‡çº§éªŒè¯ (å†™å…¥å‰) âœ…\n                      â”œâ”€ å†™å…¥ç¼“å­˜ (é˜²å¾¡æ€§å»é‡) âœ…\n                      â””â”€ äº‹åéªŒè¯ (å¢å¼ºæ—¥å¿—) âœ…\n```\n\n---\n\n## ğŸ“ ç›¸å…³æ–‡æ¡£\n\n- [å®æ–½æ€»ç»“](./IMPLEMENTATION_SUMMARY.md) - æ”¹åŠ¨æ¦‚è§ˆ\n- [æµ‹è¯•æŒ‡å—](./TESTING_GUIDE.md) - å¦‚ä½•æµ‹è¯•\n- [å¿«é€Ÿå‚è€ƒ](./QUICK_REFERENCE.md) - å¿«é€Ÿäº†è§£\n\n---\n\n**å®æ–½æ—¥æœŸ**: 2024-01-14\n\n**çŠ¶æ€**: âœ… å®Œæˆ\n