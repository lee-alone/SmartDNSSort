# 批量过期清理优化实现总结

## 实现完成时间
2026-02-02

## 优化目标
防止单次清理耗时过长导致 DNS 查询延迟尖峰。

---

## 实现内容

### 1. 添加清理限制常量

在 `cache/cache.go` 开头添加了两个常量：

```go
const (
    // MaxCleanupBatchSize 单次清理最多处理的条目数
    // 防止在大量过期条目时，单次清理耗时过长
    MaxCleanupBatchSize = 200

    // MaxCleanupDuration 单次清理最多耗时
    // 防止清理操作阻塞 DNS 查询
    MaxCleanupDuration = 10 * time.Millisecond
)
```

**参数说明**：
- `MaxCleanupBatchSize = 200`：每次清理最多处理 200 个条目
- `MaxCleanupDuration = 10ms`：每次清理最多耗时 10 毫秒

这些参数可以根据实际情况调整。

---

### 2. 改进 CleanExpired 方法

在 `CleanExpired()` 方法中添加了批量清理限制：

```go
// 批量清理限制
startTime := timeNow()
cleanedCount := 0

// 堆是按过期时间排序的
for len(c.expiredHeap) > 0 {
    // 检查是否超过清理限制
    if cleanedCount >= MaxCleanupBatchSize {
        // 已清理足够多的条目，停止本次清理
        break
    }
    if timeNow().Sub(startTime) > MaxCleanupDuration {
        // 本次清理已耗时过长，停止以避免阻塞 DNS 查询
        break
    }
    
    // ... 处理逻辑 ...
    cleanedCount++ // 增加清理计数
}

// 记录清理统计信息
c.lastCleanupTime = timeNow()
c.lastCleanupCount = cleanedCount
c.lastCleanupDuration = timeNow().Sub(startTime)
```

**工作原理**：
1. 记录清理开始时间
2. 在循环中检查两个条件：
   - 已清理的条目数是否达到 `MaxCleanupBatchSize`
   - 清理耗时是否超过 `MaxCleanupDuration`
3. 如果任一条件满足，停止本次清理
4. 记录清理统计信息供监控使用

---

### 3. 添加清理统计字段

在 `Cache` 结构体中添加了三个字段用于监控：

```go
// 清理统计（用于监控）
lastCleanupTime   time.Time     // 最后一次清理的时间
lastCleanupCount  int           // 最后一次清理清理的条目数
lastCleanupDuration time.Duration // 最后一次清理的耗时
```

---

### 4. 添加清理统计查询方法

新增 `CleanupStats` 结构体和 `GetCleanupStats()` 方法：

```go
// CleanupStats 清理统计信息
type CleanupStats struct {
    LastCleanupTime     time.Time     // 最后一次清理的时间
    LastCleanupCount    int           // 最后一次清理清理的条目数
    LastCleanupDuration time.Duration // 最后一次清理的耗时
    HeapSize            int           // 当前过期堆的大小
    MaxBatchSize        int           // 单次清理的最大条目数
    MaxDuration         time.Duration // 单次清理的最大耗时
}

// GetCleanupStats 获取清理统计信息
func (c *Cache) GetCleanupStats() CleanupStats {
    c.mu.RLock()
    defer c.mu.RUnlock()

    return CleanupStats{
        LastCleanupTime:     c.lastCleanupTime,
        LastCleanupCount:    c.lastCleanupCount,
        LastCleanupDuration: c.lastCleanupDuration,
        HeapSize:            len(c.expiredHeap),
        MaxBatchSize:        MaxCleanupBatchSize,
        MaxDuration:         MaxCleanupDuration,
    }
}
```

**使用示例**：
```go
stats := cache.GetCleanupStats()
fmt.Printf("Last cleanup: %v, cleaned %d entries in %v\n",
    stats.LastCleanupTime,
    stats.LastCleanupCount,
    stats.LastCleanupDuration)
fmt.Printf("Heap size: %d, max batch: %d, max duration: %v\n",
    stats.HeapSize,
    stats.MaxBatchSize,
    stats.MaxDuration)
```

---

## 性能影响

### 优势

1. **防止长尾延迟**
   - 单次清理最多耗时 10ms
   - 不会阻塞 DNS 查询（通常 < 1ms）
   - 即使在大量过期条目的情况下也能保证响应时间

2. **可预测的性能**
   - 清理耗时有上界
   - 便于性能分析和容量规划

3. **可观测性**
   - 通过 `GetCleanupStats()` 可以监控清理情况
   - 便于调整参数

### 权衡

1. **清理可能不完全**
   - 如果过期条目很多，可能需要多次清理才能清完
   - 但这是可接受的，因为清理是后台操作

2. **参数调整**
   - `MaxCleanupBatchSize = 200` 和 `MaxCleanupDuration = 10ms` 是初始值
   - 可以根据实际情况调整：
     - 如果清理不及时，增加这两个值
     - 如果清理影响 DNS 查询，减少这两个值

---

## 修改的文件

1. **cache/cache.go**
   - 添加了 `MaxCleanupBatchSize` 和 `MaxCleanupDuration` 常量
   - 改进了 `CleanExpired()` 方法，添加批量清理限制
   - 添加了 `lastCleanupTime`、`lastCleanupCount`、`lastCleanupDuration` 字段
   - 添加了 `CleanupStats` 结构体
   - 添加了 `GetCleanupStats()` 方法

---

## 验证

所有修改已通过编译检查，无语法错误或类型错误。

---

## 后续建议

### 监控指标
建议在 Web API 中添加清理统计的查询接口，便于实时监控：

```go
// 在 webapi/api.go 中添加
func (api *API) GetCacheCleanupStats(w http.ResponseWriter, r *http.Request) {
    stats := api.cache.GetCleanupStats()
    json.NewEncoder(w).Encode(stats)
}
```

### 参数调整
根据实际运行情况调整参数：
- 监控 `LastCleanupDuration` 是否经常接近 `MaxDuration`
- 监控 `HeapSize` 是否持续增长
- 根据 DNS 查询延迟调整参数

### 自适应清理
可以考虑根据内存压力自动调整清理参数：
- 高压力：增加 `MaxCleanupBatchSize` 和 `MaxCleanupDuration`
- 低压力：减少清理频率

---

## 总结

✅ **批量过期清理优化已完成**

这个优化通过添加清理限制，防止单次清理耗时过长导致 DNS 查询延迟尖峰。同时提供了清理统计信息，便于监控和调优。

**关键改进**：
- 单次清理最多耗时 10ms，不会阻塞 DNS 查询
- 清理耗时有上界，性能可预测
- 提供清理统计信息供监控使用
