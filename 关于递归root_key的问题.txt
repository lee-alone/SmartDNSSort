ä»£ç åœ¨debianä¸‹è¿è¡Œçš„æ—¶å€™ æˆ‘å‘ç° /etc/unbound/root.key è¿™ä¸ªæ–‡ä»¶å¹¶ä¸å­˜åœ¨ï¼Œå› ä¸ºä»…å®‰è£…unboundæ˜¯ä¸ä¼šæœ‰è¿™ä¸ªæ–‡ä»¶çš„ã€‚
è™½ç„¶æ²¡æœ‰è¿™ä¸ªæ–‡ä»¶ã€‚ç›®å‰unboundæ²¡æœ‰å¼ºåˆ¶ä½¿ç”¨dnssecæ‰€ä»¥è¿˜å¯ä»¥å¯åŠ¨ã€‚ä½œä¸ºdnsæœåŠ¡å™¨è‚¯å®šæ˜¯è¦è”ç½‘çš„ã€‚æ‰€ä»¥æˆ‘å€¾å‘éœ€è¦ç³»ç»Ÿè‡ªè¡Œä¸‹è½½ã€‚æ¯•ç«Ÿè¿™ä¸ªæ–‡ä»¶ä¹Ÿä¸å¤§ã€‚
ä½ çš„æ€è·¯éå¸¸æ­£ç¡®ï¼ä½œä¸ºDNSæœåŠ¡å™¨ç¡®å®åº”è¯¥è”ç½‘ï¼Œä½¿ç”¨ç³»ç»Ÿæ ‡å‡†å·¥å…· `unbound-anchor` æ›´åˆé€‚ã€‚è®©æˆ‘è®¾è®¡ä¸€ä¸ªæ··åˆæ–¹æ¡ˆï¼š

## ğŸ¯ æ¨èæ–¹æ¡ˆï¼šç³»ç»Ÿå·¥å…· + åµŒå…¥Fallback

### æ ¸å¿ƒé€»è¾‘
```
1. é¦–æ¬¡å¯åŠ¨ï¼šå°è¯• `unbound-anchor` ç”Ÿæˆ root.key
2. å¦‚æœæˆåŠŸï¼šä½¿ç”¨ç³»ç»Ÿç”Ÿæˆçš„æ–‡ä»¶
3. å¦‚æœå¤±è´¥ï¼ˆç½‘ç»œå—é™/DNSæœªå¯åŠ¨ï¼‰ï¼šä½¿ç”¨åµŒå…¥çš„ root.key
4. åå°å®šæœŸï¼šæ¯30å¤©å°è¯•æ›´æ–°ä¸€æ¬¡
```

---

## ğŸ“ å®ç°ä»£ç 

### 1. ä¿®æ”¹ `recursor/system_manager.go` æ·»åŠ  root.key ç®¡ç†

```go
// ensureRootKey ç¡®ä¿ root.key å­˜åœ¨
// ä¼˜å…ˆä½¿ç”¨ unbound-anchor ç”Ÿæˆï¼Œå¤±è´¥æ—¶ä½¿ç”¨åµŒå…¥æ–‡ä»¶ä½œä¸º fallback
func (sm *SystemManager) ensureRootKey() (string, error) {
    rootKeyPath := "/etc/unbound/root.key"
    
    // 1. å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼ŒéªŒè¯æ–‡ä»¶æ˜¯å¦æœ‰æ•ˆ
    if _, err := os.Stat(rootKeyPath); err == nil {
        // æ–‡ä»¶å­˜åœ¨ï¼ŒéªŒè¯æ–‡ä»¶å¤§å°ï¼ˆroot.key é€šå¸¸å‡ KBåˆ°å‡ åKBï¼‰
        info, _ := os.Stat(rootKeyPath)
        if info.Size() < 1024 {
            logger.Warnf("[SystemManager] Root key file seems too small: %d bytes", info.Size())
        } else {
            logger.Infof("[SystemManager] Using existing root.key: %s", rootKeyPath)
            return rootKeyPath, nil
        }
    }
    
    // 2. ç¡®ä¿ç›®å½•å­˜åœ¨
    if err := os.MkdirAll("/etc/unbound", 0755); err != nil {
        return "", fmt.Errorf("failed to create /etc/unbound: %w", err)
    }
    
    // 3. å°è¯•ä½¿ç”¨ unbound-anchor ç”Ÿæˆ
    logger.Infof("[SystemManager] Attempting to generate root.key using unbound-anchor...")
    if err := sm.runUnboundAnchor(rootKeyPath); err != nil {
        logger.Warnf("[SystemManager] unbound-anchor failed: %v", err)
        logger.Infof("[SystemManager] Falling back to embedded root.key")
        
        // 4. ä½¿ç”¨åµŒå…¥çš„ root.key
        if err := sm.extractEmbeddedRootKey(rootKeyPath); err != nil {
            return "", fmt.Errorf("both unbound-anchor and embedded root.key failed: %w", err)
        }
        
        logger.Infof("[SystemManager] Using embedded root.key as fallback")
    } else {
        logger.Infof("[SystemManager] Root key generated successfully")
    }
    
    return rootKeyPath, nil
}

// runUnboundAnchor è¿è¡Œ unbound-anchor å‘½ä»¤ç”Ÿæˆ root.key
func (sm *SystemManager) runUnboundAnchor(rootKeyPath string) error {
    // unbound-anchor å‚æ•°ï¼š
    // -a <path>: æŒ‡å®š root.key è¾“å‡ºè·¯å¾„
    // -r <url>: æŒ‡å®š root.key ä¸‹è½½URLï¼ˆå¯é€‰ï¼Œé»˜è®¤ä½¿ç”¨å®˜æ–¹URLï¼‰
    // -4: å¼ºåˆ¶ä½¿ç”¨ IPv4ï¼ˆå¯é€‰ï¼‰
    
    cmd := exec.Command("unbound-anchor", "-a", rootKeyPath, "-4")
    output, err := cmd.CombinedOutput()
    
    if err != nil {
        logger.Debugf("[SystemManager] unbound-anchor output:\n%s", string(output))
        
        // å¸¸è§é”™è¯¯ï¼š
        // - DNS resolution failedï¼ˆé¦–æ¬¡å¯åŠ¨æ—¶DNSå¯èƒ½æœªå°±ç»ªï¼‰
        // - Network unreachable
        // - Timeout
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸´æ—¶æ€§é”™è¯¯ï¼ˆå¯ä»¥fallbackï¼‰
        if sm.isTemporaryAnchorError(err, string(output)) {
            return err // è¿”å›é”™è¯¯ï¼Œè®©è°ƒç”¨è€…ä½¿ç”¨fallback
        }
        
        // ä¸¥é‡é”™è¯¯ï¼Œä¸åº”è¯¥fallback
        return fmt.Errorf("unbound-anchor critical error: %w", err)
    }
    
    return nil
}

// isTemporaryAnchorError åˆ¤æ–­æ˜¯å¦æ˜¯ä¸´æ—¶æ€§é”™è¯¯ï¼ˆå¯ä»¥ä½¿ç”¨fallbackï¼‰
func (sm *SystemManager) isTemporaryAnchorError(err error, output string) bool {
    // è¿™äº›é”™è¯¯è¢«è®¤ä¸ºæ˜¯ä¸´æ—¶æ€§çš„ï¼Œå¯ä»¥ä½¿ç”¨åµŒå…¥çš„ root.key
    temporaryErrors := []string{
        "timeout",           // è¶…æ—¶
        "network unreachable", // ç½‘ç»œä¸å¯è¾¾
        "connection refused", // è¿æ¥æ‹’ç»
        "resolution failed",   // DNSè§£æå¤±è´¥
        "no address",         // æ— æ³•è§£æåœ°å€
        "could not fetch",     // æ— æ³•è·å–
    }
    
    outputLower := strings.ToLower(string(output)) + strings.ToLower(err.Error())
    
    for _, errPattern := range temporaryErrors {
        if strings.Contains(outputLower, errPattern) {
            return true
        }
    }
    
    return false
}

// extractEmbeddedRootKey ä»åµŒå…¥æ–‡ä»¶ä¸­æå– root.key
func (sm *SystemManager) extractEmbeddedRootKey(targetPath string) error {
    // ä»åµŒå…¥çš„æ–‡ä»¶ç³»ç»Ÿä¸­è¯»å– root.key
    data, err := unboundBinaries.ReadFile("data/root.key")
    if err != nil {
        return fmt.Errorf("embedded root.key not found: %w", err)
    }
    
    // å†™å…¥ç›®æ ‡è·¯å¾„
    if err := os.WriteFile(targetPath, data, 0644); err != nil {
        return fmt.Errorf("failed to write embedded root.key to %s: %w", targetPath, err)
    }
    
    return nil
}

// tryUpdateRootKey å°è¯•æ›´æ–° root.keyï¼ˆåå°ä»»åŠ¡ï¼‰
func (sm *SystemManager) tryUpdateRootKey() error {
    rootKeyPath := "/etc/unbound/root.key"
    
    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if _, err := os.Stat(rootKeyPath); os.IsNotExist(err) {
        // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè°ƒç”¨ ensureRootKey ç”Ÿæˆ
        return sm.ensureRootKey()
    }
    
    // æ–‡ä»¶å­˜åœ¨ï¼Œå°è¯•æ›´æ–°
    logger.Infof("[SystemManager] Attempting to update root.key...")
    cmd := exec.Command("unbound-anchor", "-a", rootKeyPath, "-4")
    output, err := cmd.CombinedOutput()
    
    if err != nil {
        logger.Debugf("[SystemManager] Root key update failed (non-critical): %v", err)
        logger.Debugf("[SystemManager] Output: %s", string(output))
        // æ›´æ–°å¤±è´¥ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œç»§ç»­ä½¿ç”¨ç°æœ‰çš„ root.key
        return nil
    }
    
    logger.Infof("[SystemManager] Root key updated successfully")
    return nil
}

// InstallUnbound åœ¨å®‰è£…å®Œæˆåç”Ÿæˆ root.key
func (sm *SystemManager) InstallUnbound() error {
    // ... ç°æœ‰çš„å®‰è£…é€»è¾‘ä¿æŒä¸å˜
    
    // ç­‰å¾…æ›´é•¿æ—¶é—´ï¼Œç¡®ä¿å®‰è£…å®Œæˆå’Œ PATH æ›´æ–°
    time.Sleep(2 * time.Second)

    // éªŒè¯ unbound æ˜¯å¦çœŸçš„å·²å®‰è£…
    if !sm.IsUnboundInstalled() {
        return fmt.Errorf("unbound installation verification failed: executable not found in PATH")
    }

    // è·å–ç‰ˆæœ¬å’Œè·¯å¾„
    ver, err := sm.GetUnboundVersion()
    if err != nil {
        return fmt.Errorf("failed to get unbound version after installation: %w", err)
    }
    sm.unboundVer = ver

    path, err := sm.getUnboundPath()
    if err != nil {
        return fmt.Errorf("failed to get unbound path after installation: %w", err)
    }
    sm.unboundPath = path

    // ç”Ÿæˆ root.key
    if _, err := sm.ensureRootKey(); err != nil {
        logger.Warnf("[SystemManager] Warning: %v", err)
        logger.Warnf("[SystemManager] DNSSEC validation may be limited")
    }

    return nil
}
```

---

### 2. ä¿®æ”¹ `recursor/manager_linux.go` å¯åŠ¨å‰ç¡®ä¿ root.key

```go
// startPlatformSpecificNoInit Linux ç‰¹å®šçš„å¯åŠ¨é€»è¾‘ï¼ˆä¸è°ƒç”¨ Initializeï¼‰
func (m *Manager) startPlatformSpecificNoInit() error {
    // 1. è·å– unbound è·¯å¾„
    if m.sysManager != nil {
        m.unboundPath = m.sysManager.unboundPath
        logger.Infof("[Recursor] Using system unbound: %s", m.unboundPath)
    }

    // 2. ç¡®ä¿ root.key å­˜åœ¨
    var rootKeyPath string
    if m.sysManager != nil {
        var err error
        rootKeyPath, err = m.sysManager.ensureRootKey()
        if err != nil {
            logger.Warnf("[Recursor] Failed to ensure root.key: %v", err)
            // éè‡´å‘½é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œ
            logger.Warnf("[Recursor] DNSSEC validation may be disabled")
            rootKeyPath = "/etc/unbound/root.key" // ä»åœ¨é…ç½®ä¸­å¼•ç”¨
        } else {
            logger.Infof("[Recursor] Root key ready: %s", rootKeyPath)
        }
    } else {
        // å›é€€ï¼šç›´æ¥ä½¿ç”¨æ ‡å‡†è·¯å¾„
        rootKeyPath = "/etc/unbound/root.key"
    }

    // 3. ç”Ÿæˆé…ç½®æ–‡ä»¶ï¼ˆä¼ é€’ root.key è·¯å¾„ï¼‰
    configPath, err := m.generateConfigLinux(rootKeyPath)
    if err != nil {
        return fmt.Errorf("failed to generate unbound config: %w", err)
    }
    m.configPath = configPath
    logger.Infof("[Recursor] Generated config file: %s", configPath)

    // éªŒè¯é…ç½®æ–‡ä»¶
    if !fileExists(configPath) {
        return fmt.Errorf("config file not found after generation: %s", configPath)
    }

    return nil
}

// generateConfigLinux Linux ç‰¹å®šçš„é…ç½®ç”Ÿæˆ
func (m *Manager) generateConfigLinux(rootKeyPath string) (string, error) {
    configPath := "/etc/unbound/unbound.conf.d/smartdnssort.conf"

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    configDir := filepath.Dir(configPath)
    if err := os.MkdirAll(configDir, 0755); err != nil {
        return "", fmt.Errorf("failed to create config directory: %w", err)
    }

    // è·å–ç‰ˆæœ¬ä¿¡æ¯
    version := ""
    if m.sysManager != nil {
        version = m.sysManager.unboundVer
    }

    // ä½¿ç”¨ ConfigGenerator ç”Ÿæˆé…ç½®
    sysInfo := SystemInfo{
        CPUCores: runtime.NumCPU(),
        MemoryGB: 0, // è§¦å‘ä¿å®ˆé…ç½®
    }
    generator := NewConfigGenerator(version, sysInfo, m.port)
    
    // å¦‚æœ root.key è·¯å¾„ä¸æ˜¯é»˜è®¤è·¯å¾„ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
    if rootKeyPath != "/etc/unbound/root.key" {
        // å¯ä»¥åœ¨ ConfigGenerator ä¸­æ·»åŠ  SetRootKeyPath æ–¹æ³•
        // æˆ–è€…ç›´æ¥åœ¨è¿™é‡Œä¿®æ”¹ç”Ÿæˆçš„é…ç½®
    }
    
    config, err := generator.GenerateConfig()
    if err != nil {
        return "", fmt.Errorf("failed to generate config: %w", err)
    }

    // å¦‚æœ root.key è·¯å¾„ä¸æ˜¯é»˜è®¤è·¯å¾„ï¼Œæ›¿æ¢é…ç½®ä¸­çš„è·¯å¾„
    if rootKeyPath != "/etc/unbound/root.key" {
        config = strings.ReplaceAll(config, "/etc/unbound/root.key", rootKeyPath)
    }

    if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
        return "", fmt.Errorf("failed to write config file: %w", err)
    }

    return configPath, nil
}
```

---

### 3. åœ¨ `recursor/manager.go` ä¸­æ·»åŠ å®šæœŸæ›´æ–°ä»»åŠ¡

```go
// Start å¯åŠ¨åµŒå…¥çš„ Unbound è¿›ç¨‹
// ... å‰é¢çš„ä»£ç ä¿æŒä¸å˜ ...

    // 6. å¯åŠ¨å¥åº·æ£€æŸ¥/ä¿æ´» loop
    go m.healthCheckLoop()

    // æ–°å¢ï¼šå¯åŠ¨ root.key å®šæœŸæ›´æ–°ä»»åŠ¡
    if runtime.GOOS == "linux" && m.sysManager != nil {
        go m.updateRootKeyInBackground()
    }

    return nil
}

// updateRootKeyInBackground åå°å®šæœŸæ›´æ–° root.key
func (m *Manager) updateRootKeyInBackground() {
    ticker := time.NewTicker(30 * 24 * time.Hour) // æ¯30å¤©æ›´æ–°ä¸€æ¬¡
    defer ticker.Stop()

    // é¦–æ¬¡æ›´æ–°ï¼šå¯åŠ¨åç­‰å¾…1å°æ—¶ï¼Œç»™ç³»ç»Ÿä¸€äº›æ—¶é—´ç¨³å®šç½‘ç»œ
    time.Sleep(1 * time.Hour)

    logger.Infof("[Recursor] Root key update scheduler started (every 30 days)")

    for {
        select {
        case <-ticker.C:
            logger.Infof("[Recursor] Scheduled root.key update...")
            if m.sysManager != nil {
                if err := m.sysManager.tryUpdateRootKey(); err != nil {
                    logger.Warnf("[Recursor] Root key update failed: %v", err)
                }
            }
        case <-m.stopCh:
            logger.Debugf("[Recursor] Root key update scheduler stopped")
            return
        case <-m.healthCtx.Done():
            logger.Debugf("[Recursor] Root key update scheduler cancelled")
            return
        }
    }
}
```

---

### 4. ä¿®æ”¹ `recursor/manager.go` çš„ Stop æ–¹æ³•ï¼Œç¡®ä¿åœæ­¢æ›´æ–°ä»»åŠ¡

```go
// Stop åœæ­¢ Unbound è¿›ç¨‹
func (m *Manager) Stop() error {
    m.mu.Lock()

    if !m.enabled {
        m.mu.Unlock()
        return nil
    }

    m.enabled = false

    // å–æ¶ˆæ‰€æœ‰ goroutineï¼ˆåŒ…æ‹¬ root.key æ›´æ–°ä»»åŠ¡ï¼‰
    if m.monitorCancel != nil {
        m.monitorCancel()
    }
    if m.healthCancel != nil {
        m.healthCancel()
    }

    oldStopCh := m.stopCh
    m.mu.Unlock()

    // ... åé¢çš„ä»£ç ä¿æŒä¸å˜ ...
```

---

## ğŸ“Š æ–¹æ¡ˆä¼˜åŠ¿æ€»ç»“

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| âœ… **æ ‡å‡†åšæ³•** | ä½¿ç”¨ `unbound-anchor`ï¼Œç¬¦åˆ Debian/Ubuntu æ ‡å‡† |
| âœ… **æœ‰Fallback** | ç½‘ç»œå—é™æ—¶ä½¿ç”¨åµŒå…¥çš„ root.key |
| âœ… **è‡ªåŠ¨æ›´æ–°** | åå°å®šæœŸæ›´æ–°ï¼ˆæ¯30å¤©ï¼‰ |
| âœ… **æ—¥å¿—å®Œå–„** | è¯¦ç»†è®°å½•ç”Ÿæˆã€æ›´æ–°ã€fallback çš„è¿‡ç¨‹ |
| âœ… **é”™è¯¯åˆ†ç±»** | åŒºåˆ†ä¸´æ—¶é”™è¯¯å’Œä¸¥é‡é”™è¯¯ |
| âœ… **éé˜»å¡** | æ›´æ–°å¤±è´¥ä¸å½±å“DNSæœåŠ¡ |

---

## ğŸ”„ å·¥ä½œæµç¨‹å›¾

```
é¦–æ¬¡å¯åŠ¨ï¼š
â”œâ”€ å°è¯• unbound-anchor
â”‚   â”œâ”€ æˆåŠŸ â†’ ä½¿ç”¨ç³»ç»Ÿç”Ÿæˆçš„ root.key
â”‚   â””â”€ å¤±è´¥ï¼ˆç½‘ç»œå—é™ï¼‰â†’ ä½¿ç”¨åµŒå…¥çš„ root.key
â”‚
â””â”€ å¯åŠ¨ Unbound

è¿è¡Œä¸­ï¼ˆæ¯30å¤©ï¼‰ï¼š
â”œâ”€ å°è¯•æ›´æ–° root.key
â”‚   â”œâ”€ æˆåŠŸ â†’ æ›´æ–°æˆåŠŸï¼Œæ—¥å¿—è®°å½•
â”‚   â””â”€ å¤±è´¥ â†’ ç»§ç»­ä½¿ç”¨æ—§æ–‡ä»¶ï¼ˆéè‡´å‘½ï¼‰
â”‚
â””â”€ DNSæœåŠ¡ç»§ç»­è¿è¡Œ
```

---

## ğŸ’¡ é¢å¤–ä¼˜åŒ–å»ºè®®

### 1. æ£€æµ‹æ˜¯å¦ä½¿ç”¨åµŒå…¥çš„ root.key

åœ¨å¯åŠ¨æˆåŠŸåï¼Œè®°å½•å½“å‰ä½¿ç”¨çš„ root.key æ¥æºï¼š

```go
// ensureRootKey è¿”å›ä½¿ç”¨çš„ä¿¡æ¯
type RootKeyInfo struct {
    Path      string
    Source    string // "system" | "embedded" | "existing"
    Timestamp time.Time
}

// åœ¨æ—¥å¿—ä¸­æ˜¾ç¤º
logger.Infof("[SystemManager] Root key: path=%s, source=%s", info.Path, info.Source)
```

### 2. é…ç½®æ–‡ä»¶ä¸­æ·»åŠ è¯´æ˜

```go
config := fmt.Sprintf(`# ...
# DNSSEC ä¿¡ä»»é”š
# Root key ä½ç½®: %s
# æ¥æº: %s
# æ³¨æ„ï¼šå¦‚æœä½¿ç”¨åµŒå…¥çš„ root.keyï¼Œå°†åœ¨30å¤©åå°è¯•æ›´æ–°
auto-trust-anchor-file: "%s"
`, ...
```

---

éœ€è¦æˆ‘å¸®ä½ å®ç°è¿™äº›ä¿®æ”¹å—ï¼Ÿè¿˜æ˜¯ä½ æ‰“ç®—æ‰‹åŠ¨é›†æˆåˆ°ç°æœ‰çš„ä»£ç ä¸­ï¼Ÿ