# IP 测速排序修复 - 测试指南

## 修复内容

在 `dnsserver/handler_cache.go` 的 `handleRawCacheHit()` 函数中添加了排序缓存检查逻辑，确保后续查询优先使用测速排序结果，而不是历史排序。

## 测试场景

### 场景 1：首次查询（验证快速响应）

**目标**：验证首次查询能快速返回结果，使用历史排序

**步骤**：
1. 启动 DNS 服务器
2. 查询一个新域名（例如 `dig example.com @localhost`）
3. 观察日志输出

**预期结果**：
```
[handleQuery] 原始缓存命中: example.com (type=A) -> [IP1, IP2, IP3]
[handleQuery] 使用兜底排序: example.com (type=A) -> [IP1, IP2, IP3]
[sortIPsAsync] 启动异步排序任务: example.com (type=A), IP数量=3
```

**说明**：
- 首次查询使用 `fallbackIPs`（历史排序）快速响应
- 同时异步启动排序任务进行 ping 测速

---

### 场景 2：排序完成后的查询（验证测速排序）

**目标**：验证排序完成后，后续查询使用排序缓存中的测速结果

**步骤**：
1. 执行场景 1 的查询
2. 等待 5-10 秒（让排序任务完成）
3. 再次查询同一域名（例如 `dig example.com @localhost`）
4. 观察日志输出和 IP 顺序

**预期结果**：
```
[handleQuery] 排序缓存命中: example.com (type=A) -> [IP2, IP1, IP3]
[handleSortedCacheHit] 排序完成: example.com (type=A) -> [IP2, IP1, IP3] (RTT: [50, 100, 150])
```

**说明**：
- 排序缓存命中，直接返回排序结果
- IP 顺序应该按测速结果排序（RTT 从小到大）
- 不再是按数值大小排序

---

### 场景 3：排序缓存过期后的查询（验证兜底方案）

**目标**：验证排序缓存过期后，使用历史排序作为兜底

**步骤**：
1. 执行场景 2 的查询
2. 等待排序缓存过期（根据 `Ping.RttCacheTtlSeconds` 配置，默认 300 秒）
3. 再次查询同一域名
4. 观察日志输出

**预期结果**：
```
[handleQuery] 原始缓存命中: example.com (type=A) -> [IP1, IP2, IP3]
[handleQuery] 使用兜底排序: example.com (type=A) -> [IP1, IP2, IP3]
[sortIPsAsync] 启动异步排序任务: example.com (type=A), IP数量=3
```

**说明**：
- 排序缓存已过期，回退到原始缓存
- 使用历史排序（`fallbackIPs`）快速响应
- 同时异步启动新的排序任务

---

### 场景 4：多个 IP 的排序验证

**目标**：验证多个 IP 的排序结果是否正确

**步骤**：
1. 查询一个返回多个 IP 的域名（例如 `dig google.com @localhost`）
2. 等待排序完成
3. 再次查询，观察 IP 顺序
4. 查看日志中的 RTT 值

**预期结果**：
```
[handleSortedCacheHit] 排序完成: google.com (type=A) -> [1.2.3.4, 5.6.7.8, 9.10.11.12] (RTT: [30, 50, 100])
```

**说明**：
- IP 按 RTT 从小到大排序
- RTT 值应该合理（通常在 10-500ms 之间）

---

### 场景 5：CNAME 域名的排序验证

**目标**：验证 CNAME 域名的排序是否正确

**步骤**：
1. 查询一个有 CNAME 的域名（例如 `dig www.example.com @localhost`）
2. 等待排序完成
3. 再次查询，观察响应中的 CNAME 和 IP 顺序

**预期结果**：
```
[handleQuery] 排序缓存命中: www.example.com (type=A) -> [IP1, IP2]
响应包含：
  www.example.com CNAME example.com
  example.com A IP1
  example.com A IP2
```

**说明**：
- CNAME 链正确返回
- IP 按排序结果返回

---

## 日志关键字

在测试时，可以通过以下日志关键字来追踪排序过程：

| 关键字 | 含义 |
|--------|------|
| `排序缓存命中` | 排序缓存有效，直接返回排序结果 |
| `使用兜底排序` | 排序缓存不存在，使用历史排序 |
| `启动异步排序任务` | 开始异步 ping 测速 |
| `排序完成` | ping 测速完成，结果已缓存 |
| `RTT:` | 显示每个 IP 的 RTT 值 |

---

## 性能指标

### 预期性能

- **首次查询响应时间**：< 100ms（使用历史排序快速响应）
- **排序任务完成时间**：5-30 秒（取决于 IP 数量和网络状况）
- **后续查询响应时间**：< 10ms（直接返回排序缓存）

### 监控指标

在 Web UI 或日志中查看：
- 缓存命中率（应该逐渐提高）
- 排序任务成功率（应该接近 100%）
- 平均响应时间（应该逐渐降低）

---

## 故障排查

### 问题 1：排序缓存一直不命中

**可能原因**：
- 排序任务失败
- 排序缓存 TTL 设置过短
- Ping 功能被禁用

**解决方案**：
1. 检查日志中是否有排序失败的错误
2. 检查 `Ping.Enabled` 配置是否为 `true`
3. 检查 `Ping.RttCacheTtlSeconds` 配置

### 问题 2：IP 顺序仍然按数值排序

**可能原因**：
- 排序缓存检查逻辑未生效
- 排序队列已满，排序任务未执行
- Ping 测速失败

**解决方案**：
1. 检查日志中是否有 `排序缓存命中` 的输出
2. 检查排序队列大小配置
3. 检查 Ping 测速是否成功（查看 RTT 值）

### 问题 3：排序任务超时

**可能原因**：
- 网络状况不佳
- IP 数量过多
- 排序超时时间设置过短

**解决方案**：
1. 增加排序超时时间（`SortTimeout`）
2. 减少 `Ping.MaxTestIPs` 配置
3. 检查网络连接

---

## 验证清单

- [ ] 首次查询使用历史排序快速响应
- [ ] 排序任务异步执行，不阻塞查询
- [ ] 排序完成后，后续查询使用排序缓存
- [ ] IP 顺序按 RTT 从小到大排序
- [ ] 排序缓存过期后，回退到历史排序
- [ ] CNAME 域名的排序正确
- [ ] 多个 IP 的排序结果合理
- [ ] 日志输出清晰，便于追踪

