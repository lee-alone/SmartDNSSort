# IP排序触发时机分析

## 概述

IP排序不仅在新域名及TTL过期的域名查询时触发，还有多个其他场景会触发排序。本文档详细列举所有IP排序的触发时机。

## 排序触发场景

### 1. 首次查询（缓存未命中）
**文件**: `handler_query.go`

- 当用户查询一个新域名时，上游返回结果后，会立即触发 `sortIPsAsync()` 进行排序
- 这是最常见的排序触发场景
- 流程：查询 → 上游返回 → 缓存原始结果 → 触发异步排序

### 2. TTL过期后的缓存刷新
**文件**: `handler_cache.go` + `refresh.go`

- 原始缓存过期时，触发异步刷新任务
- 刷新完成后重新排序
- 流程：缓存过期 → 提交刷新任务 → 上游查询 → 更新缓存 → 触发排序

### 3. 后台收集到更多IP时
**文件**: `server_callbacks.go`

- 当上游管理器在后台收集到新的IP（IP数量增加）时
- 会调用 `CancelSort()` 取消旧排序，然后重新排序
- 适用于多上游或后台预取场景
- 流程：后台收集IP → 检测IP数量增加 → 取消旧排序 → 触发新排序

### 4. 排序缓存数据陈旧时
**文件**: `handler_cache.go`

- 当排序缓存超过 `RttCacheTtlSeconds` 时间后变得"陈旧"
- 虽然返回陈旧数据给用户，但同时触发异步刷新和重新排序
- 这是 Stale-While-Revalidate (SWR) 模式的实现
- 流程：排序缓存命中但超过新鲜度阈值 → 返回陈旧数据 → 触发后台刷新和排序

### 5. 原始缓存未过期但需要排序
**文件**: `handler_cache.go`

- 当原始缓存命中但排序缓存不存在时
- 会调用 `sortIPsAsync()` 进行排序
- 处理排序缓存被清理但原始缓存仍有效的情况
- 流程：原始缓存命中 → 排序缓存缺失 → 触发排序

### 6. CNAME链中的每个域名
**文件**: `handler_query.go` + `refresh.go`

- 不仅对最终查询域名排序，还对CNAME链中的每个中间域名都进行排序
- 确保CNAME链中的所有域名都有排序缓存
- 流程：解析CNAME链 → 为链中每个域名创建排序任务

### 7. 排序队列满时的同步排序
**文件**: `sorting.go`

- 当异步排序队列已满时，会立即执行同步排序作为回退方案
- 虽然不是异步，但仍然会进行排序
- 流程：提交排序任务 → 队列已满 → 回退到同步排序

## 排序控制机制

### 去重机制
- 函数：`GetOrStartSort()`
- 作用：确保同一域名不会同时进行多个排序任务
- 实现：检查 `sortingState` map，如果已存在则跳过

### 取消机制
- 函数：`CancelSort()`
- 作用：允许在收集到更多IP时重新排序
- 实现：删除排序状态，清除旧的排序缓存

### 单IP优化
- 条件：只有一个IP时
- 行为：跳过排序，直接返回
- 原因：单个IP无需排序

## 排序流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    DNS查询请求                              │
└────────────────┬────────────────────────────────────────────┘
                 │
         ┌───────▼────────┐
         │ 检查缓存状态   │
         └───┬────────┬───┘
             │        │
        ┌────▼─┐  ┌──▼──────────┐
        │缓存  │  │缓存未命中    │
        │命中  │  │(首次查询)    │
        └────┬─┘  └──┬──────────┘
             │       │
        ┌────▼───────▼──────────────┐
        │ 上游查询 + 获取结果       │
        └────┬──────────────────────┘
             │
        ┌────▼──────────────────────┐
        │ 更新原始缓存              │
        └────┬──────────────────────┘
             │
        ┌────▼──────────────────────────────────────┐
        │ 触发排序 (sortIPsAsync)                   │
        │ - 检查去重 (GetOrStartSort)               │
        │ - 单IP优化                                │
        │ - 提交排序队列或同步排序                  │
        └────┬──────────────────────────────────────┘
             │
        ┌────▼──────────────────────┐
        │ 排序完成                  │
        │ 更新排序缓存              │
        └────┬──────────────────────┘
             │
        ┌────▼──────────────────────┐
        │ 返回排序结果给用户        │
        └───────────────────────────┘
```

## 特殊场景

### Stale-While-Revalidate (SWR) 模式
- 当排序缓存数据陈旧时，返回陈旧数据但强制使用较短的 TTL
- 客户端会在短时间内再次查询，届时后台刷新已完成
- 避免客户端被锁定在长 TTL 中使用失效 IP

### CNAME链处理
- 对CNAME链中的每个域名都创建缓存和排序任务
- 确保后续对中间域名的查询也能获得排序结果
- 使用最终的IP列表为整个链排序

### 后台IP收集
- 上游管理器可能在后台继续收集IP
- 当收集到更多IP时，触发重新排序
- 通过 `CancelSort()` 取消旧排序，启动新排序

## 性能优化

### 排序队列管理
- 异步排序队列有容量限制
- 队列满时回退到同步排序
- 防止排序任务堆积

### 去重机制
- 同一域名同时只有一个排序任务
- 避免重复排序浪费资源

### 单IP优化
- 单个IP直接返回，无需排序
- 减少不必要的排序开销

## 相关配置参数

| 参数 | 说明 | 文件 |
|------|------|------|
| `RttCacheTtlSeconds` | 排序缓存新鲜度阈值 | config |
| `UserReturnTTL` | 用户返回的TTL周期 | config |
| `FastResponseTTL` | 快速响应TTL | config |
| `MinTTLSeconds` | 最小TTL | config |
| `MaxTTLSeconds` | 最大TTL | config |

