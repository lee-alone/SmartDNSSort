# dnsserver æ¨¡å—æ€§èƒ½å®¡æ ¸æŠ¥å‘Š

## ðŸ“‹ å®¡æ ¸æ¦‚è¿°

æˆ‘å·²å®Œæˆå¯¹ dnsserver æ¨¡å—çš„å…¨é¢æ€§èƒ½å®¡æ ¸ã€‚è¯¥æ¨¡å—æ•´ä½“æž¶æž„åˆç†ï¼Œæœ‰è¾ƒå¤šçš„æ€§èƒ½ä¼˜åŒ–æŽªæ–½ï¼Œä½†ä»å­˜åœ¨ä¸€äº›å¯ä»¥æ”¹è¿›çš„ç©ºé—´ã€‚

---

## âœ… å½“å‰å·²å®žçŽ°çš„ä¼˜åŒ–æŽªæ–½

### 1. **å¹¶å‘ä¼˜åŒ–**
- âœ… **åˆ†ç‰‡ç¼“å­˜ï¼ˆShardedCacheï¼‰**: ä½¿ç”¨ 64 åˆ†ç‰‡ï¼Œç†è®ºä¸Šå¯èŽ·å¾— 10x+ æ€§èƒ½æå‡
- âœ… **DNSæ¶ˆæ¯å¯¹è±¡æ± **: å‡å°‘ GC åŽ‹åŠ›
- âœ… **å¼‚æ­¥æŽ’åº**: ping æŽ’åºä¸é˜»å¡žä¸»æŸ¥è¯¢æµç¨‹
- âœ… **è¿žæŽ¥æ± **: transport å±‚æ”¯æŒ TLS è¿žæŽ¥å¤ç”¨

### 2. **æŸ¥è¯¢ç­–ç•¥**
- âœ… **å¤šç­–ç•¥æ”¯æŒ**: parallel/sequential/racing/random å¯é€‰
- âœ… **ä¸¤é˜¶æ®µå¹¶è¡ŒæŸ¥è¯¢**: ä¼˜å…ˆå‘é€æœ€ä¼˜æœåŠ¡å™¨ï¼Œå»¶è¿Ÿè¡¥å…¨å…¶ä»–
- âœ… **è‡ªé€‚åº”ç­–ç•¥é€‰æ‹©**: åŸºäºŽåŽ†å²æ€§èƒ½æ•°æ®åŠ¨æ€è°ƒæ•´

### 3. **ç¼“å­˜ç®¡ç†**
- âœ… **å¤šçº§ç¼“å­˜**: DNSSEC msgCache â†’ errorCache â†’ sortedCache â†’ rawCache
- âœ… **è¿‡æœŸæ—¶é—´å †**: åŸºäºŽè¿‡æœŸæ—¶é—´çš„æœ‰åºå †ï¼Œä¾¿äºŽæ¸…ç†
- âœ… **å¼‚æ­¥å †ç»´æŠ¤**: é€šè¿‡ channel è§£é” Set è·¯å¾„

---

## âš ï¸ å‘çŽ°çš„æ€§èƒ½é—®é¢˜

### ðŸ”´ é«˜ä¼˜å…ˆçº§é—®é¢˜

#### 1. **å…¨å±€é”ç«žäº‰é£Žé™©** 
**ä½ç½®**: `dnsserver/server.go` å’Œ `cache/cache.go`

```go
// server.go: handleQuery
func (s *Server) handleQuery(w dns.ResponseWriter, r *dns.Msg) {
    s.mu.RLock()  // âš ï¸ æ¯ä¸ªæŸ¥è¯¢éƒ½è¦èŽ·å–å…¨å±€é”
    currentUpstream := s.upstream
    currentCfg := s.cfg
    // ...
    s.mu.RUnlock()
    // ...
}
```

**é—®é¢˜**:
- è™½ç„¶é”å¾ˆå¿«é‡Šæ”¾ï¼Œä½†åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼ˆQPS > 10000ï¼‰ï¼Œè¿™ä¸ªå…¨å±€é”ä»å¯èƒ½æˆä¸ºç“¶é¢ˆ
- `cache.mu` ä¹Ÿæ˜¯ä¸€ä¸ªå…¨å±€çš„ RWMutexï¼Œç”¨äºŽä¿æŠ¤å¤šä¸ªç‹¬ç«‹çš„ç¼“å­˜ç»“æž„

**å½±å“**: 
- å¢žåŠ å°¾éƒ¨å»¶è¿Ÿï¼ˆtail latencyï¼‰
- åœ¨å¤šæ ¸ CPU ä¸Šæ— æ³•å……åˆ†åˆ©ç”¨å¹¶å‘

---

#### 2. **Goroutine æ³„æ¼é£Žé™©**

**ä½ç½®**: `dnsserver/handler_query.go`, `handler_cache.go`

```go
// sortIPsAsync è¢«é¢‘ç¹è°ƒç”¨
go s.sortIPsAsync(domain, qtype, finalIPs, finalTTL, time.Now())

// refreshQueue.Submit
task := RefreshTask{Domain: domain, Qtype: qtype}
s.refreshQueue.Submit(task)
```

**é—®é¢˜**:
- æ¯ä¸ªç¼“å­˜å‘½ä¸­éƒ½å¯èƒ½è§¦å‘å¼‚æ­¥æŽ’åº goroutine
- é˜Ÿåˆ—æ»¡æ—¶ç›´æŽ¥ä¸¢å¼ƒï¼ˆ`!s.sortQueue.Submit(task)`ï¼‰ï¼Œä½†æ— ç›‘æŽ§
- DNSSEC å¤„ç†ä¸­é¢‘ç¹ä½¿ç”¨ `reply.Copy()` åˆ›å»ºå®Œæ•´æ¶ˆæ¯å‰¯æœ¬
- CNAME é“¾å¤„ç†æ—¶æ¯ä¸ªçŽ¯èŠ‚éƒ½å¯èƒ½åˆ›å»º map å’Œåˆ‡ç‰‡

**å½±å“**:
- é•¿æ—¶é—´è¿è¡ŒåŽ goroutine æ•°é‡å¯èƒ½å¤±æŽ§
- å†…å­˜å ç”¨æŒç»­å¢žé•¿
- GC åŽ‹åŠ›å¢žå¤§

---

#### 3. **Channel ç¼“å†²åŒºç“¶é¢ˆ**

**ä½ç½®**: `cache/cache.go`

```go
c = &Cache{
    // ...
    addHeapChan:     make(chan expireEntry, 1000), // âš ï¸ å›ºå®š 1000 ç¼“å†²
    // ...
}
```

**é—®é¢˜**:
- é«˜è´Ÿè½½ä¸‹ï¼ˆQPS çªå¢žï¼‰ï¼Œå¦‚æžœç”Ÿäº§é€Ÿåº¦ > æ¶ˆè´¹é€Ÿåº¦ï¼Œchannel å†™å…¥ä¼šé˜»å¡ž
- é˜»å¡žç‚¹ï¼š`SetRaw` â†’ `c.addHeapChan <- entry`
- è¿™ä¼šå°†å¼‚æ­¥æ“ä½œå˜æˆåŒæ­¥ï¼Œå¢žåŠ æŸ¥è¯¢å»¶è¿Ÿ

**å½±å“**:
- çž¬æ—¶æµé‡é«˜å³°æ—¶å“åº”æ—¶é—´æ¿€å¢ž
- å¯èƒ½è§¦å‘çº§è”é˜»å¡ž

---

### ðŸŸ¡ ä¸­ä¼˜å…ˆçº§é—®é¢˜

#### 4. **é¢‘ç¹çš„å†…å­˜åˆ†é…**

**ä½ç½®**: å¤šä¸ªæ–‡ä»¶

```go
// handler_query.go: handleCacheMiss
cnameSet := make(map[string]bool)  // æ¯æ¬¡æŸ¥è¯¢éƒ½åˆ›å»º
for _, cname := range result.CNAMEs {
    cnameSet[cname] = true
    fullCNAMEs = append(fullCNAMEs, cname)
}

// sorting.go: performPingSort  
pingResults := pinger.PingAndSort(ctx, ips, sortDomain)
var sortedIPs []string
var rtts []int
for _, result := range pingResults {
    sortedIPs = append(sortedIPs, result.IP)
    rtts = append(rtts, result.RTT)
}
```

**é—®é¢˜**:
- CNAME é“¾å¤„ç†æ—¶é¢‘ç¹åˆ›å»º map å’Œåˆ‡ç‰‡
- ping ç»“æžœè½¬æ¢ä¸ºç»“æž„åŒ–æ•°æ®æ—¶ä¼šé¢å¤–åˆ†é…å†…å­˜
- æ¯æ¬¡å“åº”éƒ½åˆ›å»ºæ–°çš„ `dns.Msg` å¯¹è±¡ï¼ˆè™½ç„¶é€šè¿‡ msgPool å¤ç”¨ï¼‰

**ä¼˜åŒ–æ–¹å‘**:
- ä½¿ç”¨ sync.Pool å¤ç”¨ map å’Œåˆ‡ç‰‡
- é¢„åˆ†é…åˆ‡ç‰‡å®¹é‡

---

#### 5. **ç­–ç•¥åˆ‡æ¢çš„å¼€é”€**

**ä½ç½®**: `upstream/manager.go`

```go
optimalStrategy := u.SelectOptimalStrategy()
if optimalStrategy != "" && optimalStrategy != u.strategy {
    queryStrategy = optimalStrategy
    // ...
}
```

**é—®é¢˜**:
- æ¯æ¬¡æŸ¥è¯¢éƒ½è¦è¯„ä¼°ç­–ç•¥ï¼Œå³ä½¿å¤§éƒ¨åˆ†æ—¶å€™ç­–ç•¥ä¸å˜
- ç­–ç•¥è¯„ä¼°æ¶‰åŠå¤šä¸ª map æŸ¥è¯¢å’Œè®¡ç®—

**ä¼˜åŒ–æ–¹å‘**:
- ç¼“å­˜ç­–ç•¥è¯„ä¼°ç»“æžœï¼Œå®šæœŸæ›´æ–°
- å‡å°‘ç­–ç•¥åˆ‡æ¢é¢‘çŽ‡

---

#### 6. **ç¼“å­˜ç²’åº¦è¿‡ç»†**

**ä½ç½®**: `cache/cache.go`

```go
type Cache struct {
    rawCache     *ShardedCache
    sortedCache  *LRUCache
    errorCache   *LRUCache
    blockedCache map[string]*BlockedCacheEntry
    allowedCache map[string]*AllowedCacheEntry
    msgCache     *LRUCache
    // ...
}
```

**é—®é¢˜**:
- å¤šä¸ªç‹¬ç«‹çš„ç¼“å­˜ç»“æž„ï¼Œæ¯æ¬¡è®¿é—®éœ€è¦å¤šæ¬¡ map lookup
- `blockedCache` å’Œ `allowedCache` ä½¿ç”¨æ™®é€š mapï¼Œæ— é”ä¿æŠ¤

**å½±å“**:
- å¢žåŠ ç¼“å­˜è®¿é—®è·¯å¾„é•¿åº¦
- æ½œåœ¨çš„å¹¶å‘å®‰å…¨é—®é¢˜

---

### ðŸŸ¢ ä½Žä¼˜å…ˆçº§é—®é¢˜

#### 7. **æ—¥å¿—æ€§èƒ½å½±å“**

**ä½ç½®**: å¤šä¸ªæ–‡ä»¶

```go
logger.Debugf("[handleQuery] æŸ¥è¯¢: %s (type=%s)", domain, dns.TypeToString[qtype])
```

**é—®é¢˜**:
- å¤§é‡ Debug æ—¥å¿—åœ¨çƒ­è·¯å¾„ä¸Š
- å³ä½¿æ—¥å¿—çº§åˆ«å…³é—­ï¼Œå­—ç¬¦ä¸²æ ¼å¼åŒ–ä»ä¼šæ‰§è¡Œï¼ˆå–å†³äºŽ logger å®žçŽ°ï¼‰

#### 8. **ç½‘ç»œè¶…æ—¶è®¾ç½®**

**ä½ç½®**: `dnsserver/handler_query.go`

```go
totalTimeout := time.Duration(currentCfg.Upstream.TimeoutMs) * time.Millisecond
totalTimeout = min(totalTimeout, maxTotalTimeout)  // maxTotalTimeout = 30s

// Generic query
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
```

**é—®é¢˜**:
- 30 ç§’è¶…æ—¶å¯¹ DNS æŸ¥è¯¢æ¥è¯´è¿‡é•¿
- å¯èƒ½å¯¼è‡´å¤§é‡ goroutine æŒ‚èµ·

---

## ðŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### ä¼˜å…ˆçº§ 1 - ç«‹å³ä¼˜åŒ–

#### 1.1 æ¶ˆé™¤ Server å…¨å±€é”
```go
// å½“å‰ä»£ç 
func (s *Server) handleQuery(w dns.ResponseWriter, r *dns.Msg) {
    s.mu.RLock()
    currentUpstream := s.upstream
    currentCfg := s.cfg
    s.mu.RUnlock()
    // ...
}

// å»ºè®®ï¼šä½¿ç”¨ atomic.Value æˆ–åˆ†ç¦»é…ç½®å’ŒçŠ¶æ€
type Server struct {
    config atomic.Value  // *config.Config
    upstream atomic.Value  // *upstream.Manager
    // ...
}

func (s *Server) handleQuery(w dns.ResponseWriter, r *dns.Msg) {
    currentUpstream := s.upstream.Load().(*upstream.Manager)
    currentCfg := s.config.Load().(*config.Config)
    // æ— éœ€ä»»ä½•é”ï¼
}
```

**é¢„æœŸæ”¶ç›Š**: é«˜å¹¶å‘åœºæ™¯ä¸‹å»¶è¿Ÿé™ä½Ž 10-30%

---

#### 1.2 å¢žåŠ  channel ç¼“å†²åŒºå¹¶æ·»åŠ ç›‘æŽ§
```go
// å½“å‰
addHeapChan: make(chan expireEntry, 1000),

// å»ºè®®
addHeapChan: make(chan expireEntry, 10000),  // å¢žåŠ åˆ° 10k
metrics: &CacheMetrics{
    channelFullCount: atomic.Uint64{},
}

// æ·»åŠ ç›‘æŽ§
func (c *Cache) addToHeap(entry expireEntry) {
    select {
    case c.addHeapChan <- entry:
        // æˆåŠŸæ·»åŠ 
    default:
        c.metrics.channelFullCount.Add(1)
        logger.Warn("Heap channel full, dropping entry")
    }
}
```

---

#### 1.3 æ·»åŠ  goroutine é™åˆ¶å’Œç›‘æŽ§
```go
type Server struct {
    // ...
    sortSemaphore chan struct{}  // æŽ’åº goroutine ä¿¡å·é‡
    refreshSemaphore chan struct{}  // åˆ·æ–° goroutine ä¿¡å·é‡
}

// NewServer ä¸­åˆå§‹åŒ–
sortSemaphore: make(chan struct{}, 50),  // é™åˆ¶æœ€å¤š 50 ä¸ªå¹¶å‘æŽ’åº
refreshSemaphore: make(chan struct{}, 10),  // é™åˆ¶æœ€å¤š 10 ä¸ªå¹¶å‘åˆ·æ–°

// sortIPsAsync
func (s *Server) sortIPsAsync(...) {
    select {
    case s.sortSemaphore <- struct{}{}:
        defer func() { <-s.sortSemaphore }()
        // æ‰§è¡ŒæŽ’åº
    default:
        logger.Warn("Sort semaphore full, skipping")
        return
    }
}
```

---

### ä¼˜å…ˆçº§ 2 - ä¸­æœŸä¼˜åŒ–

#### 2.1 å†…å­˜åˆ†é…ä¼˜åŒ–
```go
// ä½¿ç”¨ sync.Pool å¤ç”¨ä¸´æ—¶å¯¹è±¡
var (
    stringSlicePool = sync.Pool{
        New: func() interface{} {
            return make([]string, 0, 8)
        },
    }
    stringSetPool = sync.Pool{
        New: func() interface{} {
            return make(map[string]bool)
        },
    }
)

func (s *Server) handleCacheMiss(...) {
    fullCNAMEs := stringSlicePool.Get().([]string)[:0]
    defer stringSlicePool.Put(fullCNAMEs)
    
    cnameSet := stringSetPool.Get().(map[string]bool)
    defer func() {
        for k := range cnameSet {
            delete(cnameSet, k)
        }
        stringSetPool.Put(cnameSet)
    }()
    
    // ä½¿ç”¨ fullCNAMEs å’Œ cnameSet
}
```

---

#### 2.2 å‡å°‘ DNS æ¶ˆæ¯æ‹·è´
```go
// å½“å‰: reply.Copy() åˆ›å»ºå®Œæ•´å‰¯æœ¬
msgToCache := result.DnsMsg.Copy()

// å»ºè®®ï¼šåªç¼“å­˜å¿…è¦çš„éƒ¨åˆ†
type CachedMsg struct {
    Answers []dns.RR
    Ns      []dns.RR
    Extra   []dns.RR
    TTL     uint32
}

// ä»Ž DNS æ¶ˆæ¯ä¸­æå–å¿…è¦ä¿¡æ¯
cached := &CachedMsg{
    Answers: make([]dns.RR, len(reply.Answer)),
    Ns:      make([]dns.RR, len(reply.Ns)),
    Extra:   make([]dns.RR, len(reply.Extra)),
    TTL:     calculateTTL(reply),
}
copy(cached.Answers, reply.Answer)
// ...
```

---

### ä¼˜å…ˆçº§ 3 - é•¿æœŸä¼˜åŒ–

#### 3.1 æ‰¹é‡åŒ–å¤„ç†
```go
// å½“å‰ï¼šæ¯ä¸ªæŸ¥è¯¢ç‹¬ç«‹å¤„ç†
for _, domain := range domains {
    handleQuery(domain)
}

// å»ºè®®ï¼šæ‰¹é‡å¤„ç†çƒ­ç‚¹åŸŸå
func (s *Server) batchPrefetch(domains []string) {
    // ä½¿ç”¨æ‰¹é‡çš„ ping æŽ¥å£ï¼ˆå¦‚æžœ ping åŒ…æ”¯æŒï¼‰
    results := s.pinger.BatchPing(domains)
    // æ‰¹é‡æ›´æ–°ç¼“å­˜
}
```

---

#### 3.2 ç­–ç•¥è¯„ä¼°ç¼“å­˜
```go
type Manager struct {
    // ...
    cachedStrategy string
    strategyCacheTime time.Time
    strategyCacheTTL time.Duration  // ä¾‹å¦‚ 30s
}

func (u *Manager) SelectOptimalStrategy() string {
    if time.Since(u.strategyCacheTime) < u.strategyCacheTTL {
        return u.cachedStrategy
    }
    
    // é‡æ–°è®¡ç®—
    optimal := u.calculateOptimalStrategy()
    u.cachedStrategy = optimal
    u.strategyCacheTime = time.Now()
    return optimal
}
```

---

## ðŸ“ˆ é¢„æœŸæ€§èƒ½æå‡

| ä¼˜åŒ–æŽªæ–½ | å®žæ–½éš¾åº¦ | é¢„æœŸæ”¶ç›Š |
|---------|---------|---------|
| æ¶ˆé™¤ Server å…¨å±€é” | ä¸­ | é«˜å¹¶å‘ä¸‹å»¶è¿Ÿ â†“ 20-30% |
| å¢žå¤§ channel ç¼“å†² | ä½Ž | çªå‘æµé‡ä¸‹ç¨³å®šæ€§ â†‘ |
| Goroutine é™æµ | ä¸­ | å†…å­˜å ç”¨ â†“ï¼ŒGC åŽ‹åŠ› â†“ |
| å¯¹è±¡æ± å¤ç”¨ | ä½Ž | å†…å­˜åˆ†é… â†“ 30-40% |
| å‡å°‘ DNS æ‹·è´ | ä¸­ | å†…å­˜å ç”¨ â†“ 20-50% |
| ç­–ç•¥è¯„ä¼°ç¼“å­˜ | ä½Ž | CPU ä½¿ç”¨çŽ‡ â†“ 5% |

---

## ðŸ” å»ºè®®çš„ç›‘æŽ§æŒ‡æ ‡

ä¸ºäº†æŒç»­è¯„ä¼°æ€§èƒ½ï¼Œå»ºè®®æ·»åŠ ä»¥ä¸‹æŒ‡æ ‡ï¼š

```go
type PerformanceMetrics struct {
    // é”ç«žäº‰
    ServerLockWaitDuration Histogram
    CacheLockContention Counter
    
    // Goroutines
    ActiveSortGoroutines Gauge
    ActiveRefreshGoroutines Gauge
    
    // å†…å­˜
    HeapAllocated Bytes
    DNSMessageCopies Counter
    
    // Channel
    HeapChannelFull Counter
    SortQueueFull Counter
    
    // å»¶è¿Ÿ
    QueryLatency Histogram
    SortLatency Histogram
    RefreshLatency Histogram
}
```

---

## ðŸ“ æ€»ç»“

**å½“å‰çŠ¶æ€**: 
- âœ… åŸºç¡€æž¶æž„è‰¯å¥½ï¼Œå·²æœ‰å¤šé¡¹ä¼˜åŒ–
- âš ï¸ é«˜å¹¶å‘åœºæ™¯ä¸‹å­˜åœ¨æ€§èƒ½ç“¶é¢ˆ
- âš ï¸ å†…å­˜ç®¡ç†æœ‰æ”¹è¿›ç©ºé—´

**ä¼˜åŒ–è·¯çº¿å›¾**:
1. **çŸ­æœŸï¼ˆ1-2å‘¨ï¼‰**: å¢žå¤§ channel ç¼“å†²ï¼Œæ·»åŠ ç›‘æŽ§ï¼Œä¼˜åŒ–æ—¥å¿—
2. **ä¸­æœŸï¼ˆ1ä¸ªæœˆï¼‰**: æ¶ˆé™¤å…¨å±€é”ï¼Œæ·»åŠ  goroutine é™æµï¼Œä½¿ç”¨å¯¹è±¡æ± 
3. **é•¿æœŸï¼ˆæŒç»­ï¼‰**: æ‰¹é‡åŒ–å¤„ç†ï¼Œæ·±åº¦ç¼“å­˜ä¼˜åŒ–

**å…³é”®å»ºè®®**:
ä¼˜å…ˆè§£å†³**å…¨å±€é”ç«žäº‰**å’Œ**Goroutine æ³„æ¼é£Žé™©**ï¼Œè¿™ä¸¤ä¸ªé—®é¢˜å¯¹æ€§èƒ½å½±å“æœ€å¤§ï¼Œä¸”ç›¸å¯¹å®¹æ˜“å®žæ–½ä¿®å¤ã€‚

éœ€è¦æˆ‘è¯¦ç»†å±•å¼€æŸä¸ªå…·ä½“çš„ä¼˜åŒ–æ–¹æ¡ˆå—ï¼Ÿ