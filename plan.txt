SmartDNSSort 缓存优化工作计划
项目目标
实现基于内存的智能缓存管理系统，通过LRU淘汰策略和Prefetch保护机制，最大化内存利用率，提升缓存命中率从40%到85%+。

任务分解
阶段一：配置层改造
任务1.1：扩展配置结构
文件: 
config/config.go

新增字段:

type CacheConfig struct {
    // 现有字段保持不变
    MinTTLSeconds int
    MaxTTLSeconds int
    UserReturnTTL int
    
    // 新增内存管理配置
    MaxMemoryMB              int     // 最大内存限制(MB)
    KeepExpiredEntries       bool    // 是否保留过期条目
    EvictionThreshold        float64 // 淘汰阈值(0.0-1.0)
    EvictionBatchPercent     float64 // 每次淘汰比例
    ProtectPrefetchDomains   bool    // 是否保护prefetch域名
}
新增方法:

CalculateMaxEntries() int - 根据内存大小计算最大条目数
GetDefaultCacheConfig() CacheConfig - 更新默认配置
配置文件: 
config.yaml

cache:
  max_memory_mb: 500
  keep_expired_entries: true
  eviction_threshold: 0.9
  eviction_batch_percent: 0.1
  protect_prefetch_domains: true
阶段二：缓存层改造
任务2.1：扩展缓存条目结构
文件: 
cache/cache.go

修改 RawCacheEntry:

type RawCacheEntry struct {
    // 现有字段
    IPs             []string
    CNAME           string
    UpstreamTTL     uint32
    AcquisitionTime time.Time
    
    // 新增LRU所需字段
    LastAccessTime  time.Time  // 最后访问时间
    AccessCount     int        // 访问次数统计
}
任务2.2：扩展Cache结构
文件: 
cache/cache.go

修改 Cache 结构:

type Cache struct {
    // 现有字段
    mu           sync.RWMutex
    rawCache     map[string]*RawCacheEntry
    sortedCache  map[string]*SortedCacheEntry
    sortingState map[string]*SortingState
    errorCache   map[string]*ErrorCacheEntry
    
    // 新增字段
    config       *config.CacheConfig  // 配置引用
    maxEntries   int                  // 最大条目数(根据内存计算)
    prefetcher   PrefetchChecker      // 用于检查保护域名
    
    // 统计字段
    hits   int64
    misses int64
}
新增接口:

type PrefetchChecker interface {
    IsTopDomain(domain string) bool
}
任务2.3：实现内存估算
文件: 
cache/cache.go

新增常量:

const (
    AvgRawCacheEntrySize    = 200  // 字节
    AvgSortedCacheEntrySize = 120  // 字节
    AvgDomainKeySize        = 40   // 字节
    MapOverheadPerEntry     = 50   // 字节
    AvgBytesPerDomain       = 820  // 总计(A+AAAA)
)
新增方法:

GetCurrentEntries() int - 获取当前条目数
GetCurrentMemoryUsage() int64 - 估算当前内存使用(字节)
GetMemoryUsagePercent() float64 - 获取内存使用百分比
GetExpiredEntries() int - 统计过期条目数
任务2.4：实现LRU淘汰逻辑
文件: 
cache/cache.go

重写 CleanExpired() 方法:

检查当前条目数是否达到阈值
未达阈值：直接返回，保留所有条目(包括过期)
达到阈值：调用 evictLRU()
新增 evictLRU() 方法:

收集所有条目的元数据(key, 访问时间, 是否保护, 是否过期)
排序规则:
未保护的在前(可删除)
已过期的在前(优先删除)
访问时间早的在前(LRU)
删除指定比例的条目
记录删除统计(保护域名数、过期数、活跃数)
新增 RecordAccess() 方法:

更新 LastAccessTime
增加 AccessCount
辅助函数:

extractDomain(key string) string - 从缓存key提取域名
isProtectedDomain(domain string) bool - 检查是否受保护
任务2.5：修改构造函数
文件: 
cache/cache.go

修改 NewCache():

接受 config *config.CacheConfig 参数
计算 maxEntries
初始化新增字段
返回配置好的Cache实例
阶段三：服务层集成
任务3.1：修改DNS服务器初始化
文件: 
dnsserver/server.go

修改 NewServer():

创建Cache时传入配置: cache.NewCache(&cfg.Cache)
启动后设置prefetcher引用: cache.SetPrefetcher(prefetcher)
任务3.2：记录缓存访问
文件: 
dnsserver/server.go

修改 handleQuery():

在每次 
GetRaw()
 或 
GetSorted()
 后调用 RecordAccess()
位置: 第260行、第207行附近
示例位置:

// 阶段二：排序缓存命中
if sorted, ok := s.cache.GetSorted(domain, question.Qtype); ok {
    s.cache.RecordAccess(domain, question.Qtype)  // 新增
    currentStats.IncCacheHits()
    // ... 原有逻辑
}
// 阶段三：原始缓存命中
if raw, ok := s.cache.GetRaw(domain, question.Qtype); ok {
    s.cache.RecordAccess(domain, question.Qtype)  // 新增
    currentStats.IncCacheHits()
    // ... 原有逻辑
}
阶段四：WebAPI扩展
任务4.1：新增内存统计API
文件: 
webapi/api.go

新增路由:

mux.HandleFunc("/api/cache/memory", api.handleCacheMemoryStats)
新增处理函数 handleCacheMemoryStats(): 返回JSON:

{
    "max_memory_mb": 500,
    "max_entries": 610000,
    "current_entries": 300000,
    "current_memory_mb": 245,
    "memory_percent": 49.0,
    "expired_entries": 50000,
    "expired_percent": 16.7,
    "protected_entries": 5000
}
任务4.2：扩展现有统计API
文件: 
webapi/api.go

修改 handleStats():

添加内存相关统计到现有响应
保持向后兼容
阶段五：WebUI更新
任务5.1：添加缓存内存配置面板
文件: 
webapi/web/index.html

新增配置区域:

内存限制滑块 (100MB - 4096MB)
实时显示预估条目数
淘汰阈值滑块 (70% - 95%)
淘汰批次滑块 (5% - 30%)
保留过期条目开关
保护prefetch域名开关
任务5.2：添加内存使用统计面板
文件: 
webapi/web/index.html

新增统计显示:

内存使用进度条 (当前/最大)
缓存条目数 (当前/最大)
过期条目数及百分比
受保护条目数
自动刷新(每5秒)
JavaScript功能:

fetchCacheMemoryStats() - 获取内存统计
updateMemoryDisplay() - 更新显示
calculateEstimatedEntries() - 动态计算预估条目数
updateCacheConfig() - 保存配置
实施顺序
第1步：配置层 (1-2小时)
修改 
config/config.go
 添加新字段
实现 CalculateMaxEntries() 方法
更新 
config.yaml
 示例配置
测试配置加载
第2步：缓存核心逻辑 (3-4小时)
修改 
RawCacheEntry
 结构
修改 
Cache
 结构
实现内存估算方法
实现 evictLRU() 方法
重写 
CleanExpired()
 方法
实现 RecordAccess() 方法
修改 
NewCache()
 构造函数
第3步：服务层集成 (1小时)
修改 
NewServer()
 传入配置
在 
handleQuery()
 中添加访问记录
测试缓存访问流程
第4步：WebAPI (1-2小时)
实现 handleCacheMemoryStats()
添加路由
测试API返回
第5步：WebUI (2-3小时)
设计HTML布局
实现JavaScript交互
样式美化
测试用户交互
第6步：集成测试 (2-3小时)
单元测试关键函数
集成测试完整流程
压力测试LRU淘汰
验证内存估算准确性
关键函数清单
config/config.go
CalculateMaxEntries() int - 内存转条目数
cache/cache.go
NewCache(config *config.CacheConfig) *Cache
 - 构造函数
SetPrefetcher(p PrefetchChecker) - 设置prefetcher引用
CleanExpired()
 - 智能清理入口
evictLRU() - LRU淘汰核心逻辑
RecordAccess(domain string, qtype uint16) - 记录访问
GetCurrentEntries() int - 获取条目数
GetCurrentMemoryUsage() int64 - 获取内存使用
GetMemoryUsagePercent() float64 - 获取使用率
GetExpiredEntries() int - 统计过期数
extractDomain(key string) string - 提取域名
isProtectedDomain(domain string) bool - 检查保护
dnsserver/server.go
修改 
NewServer()
 - 传入缓存配置
修改 
handleQuery()
 - 添加访问记录调用
webapi/api.go
handleCacheMemoryStats(w, r) - 内存统计API
webapi/web/index.html
fetchCacheMemoryStats() - 获取统计
updateMemoryDisplay() - 更新显示
calculateEstimatedEntries(memoryMB) - 计算条目数
updateCacheConfig(config) - 保存配置
测试计划
单元测试
TestCalculateMaxEntries - 验证内存计算
TestEvictLRU - 验证LRU排序逻辑
TestProtectedDomains - 验证保护机制
TestMemoryEstimation - 验证内存估算
集成测试
测试缓存从0到满的过程
测试达到阈值时的淘汰行为
测试prefetch域名不被淘汰
测试过期数据仍可访问
性能测试
10万条目下的淘汰性能
100万条目下的内存占用
并发访问下的锁竞争
风险与注意事项
风险点
内存估算不准确 - 实际占用可能超出预期

缓解：设置20%安全余量
LRU排序性能 - 大量条目时排序慢

缓解：仅在达到阈值时执行，批量删除
并发安全 - 多goroutine访问缓存

缓解：使用RWMutex，读多写少优化
Prefetcher循环依赖 - Cache和Prefetcher互相引用

缓解：使用接口解耦
注意事项
保持向后兼容，旧配置仍可用
添加详细日志，便于调试
提供配置验证，防止无效值
WebUI需要优雅降级(旧版本API)
验收标准
功能验收
✅ 配置文件支持 max_memory_mb
✅ 内存未满时保留过期条目
✅ 达到阈值时正确执行LRU淘汰
✅ Prefetch域名不被淘汰
✅ WebUI正确显示内存统计
✅ 配置修改实时生效
性能验收
✅ 缓存命中率提升到85%+
✅ 上游QPS降低到2以下
✅ 内存使用在配置范围内
✅ LRU淘汰耗时<100ms
用户体验验收
✅ 配置界面直观易懂
✅ 内存统计实时更新
✅ 无需重启即可调整配置
✅ 提供合理的默认值
预估工作量
开发时间: 10-15小时
测试时间: 5-8小时
文档时间: 2-3小时
总计: 17-26小时 (约3-4个工作日)
后续优化方向
自适应阈值 - 根据访问模式动态调整淘汰阈值
分层LRU - 热/温/冷三层缓存
持久化 - 缓存快照保存到磁盘
监控告警 - 内存使用率告警
差异化TTL - CDN域名短TTL，稳定域名长TTL