# 两阶段并行查询 - 流程图详解

## 1. 整体流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                      用户 DNS 查询请求                           │
│                    (example.com, type=A)                        │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    queryParallel 入口                            │
│  ├─ 获取排序后的健康服务器列表                                   │
│  └─ 分层：Active Tier (2) + Staggered Tier (3)                 │
└────────────────────────────┬────────────────────────────────────┘
                             │
                ┌────────────┴────────────┐
                │                         │
                ▼                         ▼
    ┌──────────────────────┐   ┌──────────────────────┐
    │  第一阶段            │   │  第二阶段            │
    │  Active Tier         │   │  Staggered Tier      │
    │  (立即启动)          │   │  (分组步进启动)      │
    └──────────────────────┘   └──────────────────────┘
                │                         │
                ▼                         ▼
    ┌──────────────────────┐   ┌──────────────────────┐
    │ 启动 2 个最优服务器   │   │ 等待 fallbackTimeout │
    │ (8.8.8.8, 1.1.1.1)  │   │ 或第一阶段失败       │
    └──────────────────────┘   └──────────────────────┘
                │                         │
                ▼                         ▼
    ┌──────────────────────┐   ┌──────────────────────┐
    │ 等待第一个成功响应    │   │ 启动第一批 (2 个)    │
    │ (50ms 内返回)        │   │ (208.67, 9.9.9.9)   │
    └──────────────────────┘   └──────────────────────┘
                │                         │
                ▼                         ▼
    ┌──────────────────────┐   ┌──────────────────────┐
    │ ✅ 立即响应用户       │   │ 等待 staggerDelay    │
    │ (用户感知延迟: 50ms) │   │ (50ms)               │
    └──────────────────────┘   └──────────────────────┘
                │                         │
                └────────────┬────────────┘
                             │
                             ▼
                ┌──────────────────────────┐
                │  后台收集所有响应         │
                │  (collectRemaining...)   │
                │  ├─ 收集第二阶段响应     │
                │  ├─ 合并去重             │
                │  └─ 更新缓存             │
                └──────────────────────────┘
                             │
                             ▼
                ┌──────────────────────────┐
                │  后台补全完成            │
                │  (总耗时: 400ms)         │
                │  (IP 池: 完整)           │
                └──────────────────────────┘
```

## 2. 时间轴详解

```
时间轴 (毫秒)
│
0ms  ├─ 🚀 启动 Active Tier (2 个服务器)
│    │  ├─ 服务器 A: 8.8.8.8:53
│    │  └─ 服务器 B: 1.1.1.1:53
│    │
50ms ├─ ✅ 服务器 A 返回成功
│    │  └─ 立即响应用户 (用户感知延迟: 50ms)
│    │
300ms├─ ⏱️  fallbackTimeout 触发
│    │  └─ 启动 Staggered Tier 第一批
│    │
300ms├─ 🚀 启动 Staggered Tier 第一批 (2 个服务器)
│    │  ├─ 服务器 C: 208.67.222.222:53
│    │  └─ 服务器 D: 9.9.9.9:53
│    │
350ms├─ ⏱️  staggerDelay 触发
│    │  └─ 启动 Staggered Tier 第二批
│    │
350ms├─ 🚀 启动 Staggered Tier 第二批 (1 个服务器)
│    │  └─ 服务器 E: 8.26.56.26:53
│    │
400ms├─ ✅ 所有响应收集完成
│    │  ├─ 服务器 A: 2 条记录
│    │  ├─ 服务器 B: 2 条记录
│    │  ├─ 服务器 C: 2 条记录
│    │  ├─ 服务器 D: 2 条记录
│    │  └─ 服务器 E: 2 条记录
│    │
400ms├─ 📝 合并去重 (8 条记录 → 8 条记录)
│    │
400ms├─ 💾 更新缓存
│    │
3000ms├─ ⏱️  totalCollectTimeout 硬超时
│    │  └─ 停止后台补全
│    │
```

## 3. 第一阶段详细流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    第一阶段：Active Tier                         │
│                    (极速响应)                                    │
└─────────────────────────────────────────────────────────────────┘

T=0ms
  │
  ├─ 获取排序后的服务器列表
  │  └─ [8.8.8.8 (延迟:10ms), 1.1.1.1 (延迟:20ms), ...]
  │
  ├─ 选择前 activeTierSize (2) 个
  │  └─ Active Tier: [8.8.8.8, 1.1.1.1]
  │
  ├─ 并发启动查询
  │  ├─ goroutine 1: executeQuery(8.8.8.8)
  │  └─ goroutine 2: executeQuery(1.1.1.1)
  │
  └─ 等待快速响应
     │
     ├─ 选项 1: 收到成功响应 (50ms)
     │  └─ ✅ 立即返回给用户
     │
     ├─ 选项 2: 收到失败响应 (100ms)
     │  └─ 继续等待其他响应
     │
     └─ 选项 3: fallbackTimeout (300ms)
        └─ ⏱️  启动第二阶段
```

## 4. 第二阶段详细流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    第二阶段：Staggered Tier                      │
│                    (节律补全)                                    │
└─────────────────────────────────────────────────────────────────┘

T=300ms (fallbackTimeout 触发)
  │
  ├─ 获取剩余服务器列表
  │  └─ Staggered Tier: [208.67, 9.9.9.9, 8.26.56.26]
  │
  ├─ 分组 (batchSize=2)
  │  ├─ 批次 0: [208.67, 9.9.9.9]
  │  └─ 批次 1: [8.26.56.26]
  │
  ├─ 启动批次 0 (T=300ms)
  │  ├─ goroutine 3: executeQuery(208.67)
  │  └─ goroutine 4: executeQuery(9.9.9.9)
  │
  ├─ 等待 staggerDelay (50ms)
  │
  ├─ 启动批次 1 (T=350ms)
  │  └─ goroutine 5: executeQuery(8.26.56.26)
  │
  └─ 所有批次启动完成
```

## 5. 后台收集详细流程

```
┌─────────────────────────────────────────────────────────────────┐
│              后台收集：collectRemainingResponsesWithTimeout      │
│              (合并去重 + 缓存更新)                               │
└─────────────────────────────────────────────────────────────────┘

T=50ms (快速响应返回后)
  │
  ├─ 启动后台收集 goroutine
  │
  ├─ 初始化
  │  ├─ allSuccessResults = [fastResponse]
  │  ├─ successCount = 1
  │  └─ failureCount = 0
  │
  ├─ 创建 totalCollectTimeout context (3s)
  │
  ├─ 循环收集响应
  │  │
  │  ├─ T=300ms: 收到服务器 C 的响应
  │  │  ├─ 检查错误: ✅ 成功
  │  │  ├─ successCount = 2
  │  │  └─ allSuccessResults.append(result_C)
  │  │
  │  ├─ T=320ms: 收到服务器 B 的响应
  │  │  ├─ 检查错误: ✅ 成功
  │  │  ├─ successCount = 3
  │  │  └─ allSuccessResults.append(result_B)
  │  │
  │  ├─ T=350ms: 收到服务器 D 的响应
  │  │  ├─ 检查错误: ✅ 成功
  │  │  ├─ successCount = 4
  │  │  └─ allSuccessResults.append(result_D)
  │  │
  │  ├─ T=380ms: 收到服务器 E 的响应
  │  │  ├─ 检查错误: ✅ 成功
  │  │  ├─ successCount = 5
  │  │  └─ allSuccessResults.append(result_E)
  │  │
  │  └─ T=400ms: 所有查询完成，resultChan 关闭
  │     └─ 跳出循环
  │
  ├─ 合并去重
  │  ├─ 输入: 5 个结果，共 10 条记录
  │  ├─ 处理:
  │  │  ├─ A 记录: 基于 IP 地址去重
  │  │  ├─ AAAA 记录: 基于 IP 地址去重
  │  │  ├─ CNAME 记录: 基于 Target 去重
  │  │  └─ 其他记录: 基于完整字符串去重
  │  └─ 输出: 8 条去重后的记录
  │
  ├─ 计算最小 TTL
  │  └─ minTTL = min(300, 300, 300, 300, 300) = 300
  │
  ├─ 调用缓存更新回调
  │  └─ cacheUpdateCallback(domain, qtype, mergedRecords, cnames, minTTL)
  │
  └─ 后台收集完成
```

## 6. 错误处理流程

### 场景 A：第一阶段全失败

```
T=0ms:   启动 Active Tier
         ├─ 服务器 A: 连接超时
         └─ 服务器 B: 连接拒绝
         
T=300ms: fallbackTimeout 触发
         └─ 启动 Staggered Tier
         
T=350ms: 服务器 C 返回成功
         └─ ✅ 立即响应用户
         
T=400ms: 后台补全完成
```

### 场景 B：后台补全超时

```
T=0ms:   启动 Active Tier
T=50ms:  服务器 A 返回成功
         └─ ✅ 立即响应用户
         
T=300ms: 启动 Staggered Tier
T=350ms: 启动第二批
         
T=3000ms: totalCollectTimeout 触发
          ├─ 已收集: 3 个成功响应
          ├─ 未收集: 2 个响应（可能超时或失败）
          └─ 使用已收集的结果更新缓存
```

### 场景 C：所有服务器都失败

```
T=0ms:   启动 Active Tier
         ├─ 服务器 A: 失败
         └─ 服务器 B: 失败
         
T=300ms: fallbackTimeout 触发
         └─ 启动 Staggered Tier
         
T=350ms: 所有 Staggered Tier 服务器也失败
         
T=3000ms: totalCollectTimeout 触发
          └─ ❌ 返回错误
```

## 7. 与 Singleflight 的协作

```
┌─────────────────────────────────────────────────────────────────┐
│                    Singleflight 去重机制                        │
└─────────────────────────────────────────────────────────────────┘

请求 1: example.com (T=0ms)
  │
  ├─ Singleflight 检查: 未在进行中
  │
  ├─ 触发 Parallel 查询
  │  ├─ 第一阶段: 启动 2 个服务器
  │  ├─ T=50ms: 返回快速响应
  │  └─ 后台补全: 启动分组步进
  │
  └─ 返回结果给请求 1

请求 2: example.com (T=10ms, 同时到达)
  │
  ├─ Singleflight 检查: 在进行中 (请求 1)
  │
  ├─ 等待请求 1 的结果
  │
  └─ 返回相同结果给请求 2 (无额外查询)

请求 3: example.com (T=400ms, 后台补全中)
  │
  ├─ Singleflight 检查: 在进行中 (请求 1 的后台补全)
  │
  ├─ 等待后台补全完成
  │
  └─ 返回完整结果给请求 3 (包含所有 IP)
```

## 8. 并发流程图

```
时间轴 ────────────────────────────────────────────────────────────>

主线程
  │
  ├─ T=0ms:   queryParallel 开始
  │  │
  │  ├─ 启动 Active Tier goroutines (2 个)
  │  │
  │  ├─ 等待快速响应
  │  │
  │  ├─ T=50ms: 收到快速响应
  │  │  └─ 立即返回给用户 ✅
  │  │
  │  ├─ 启动后台收集 goroutine
  │  │
  │  └─ queryParallel 返回
  │
后台线程 1 (launchStaggeredTier)
  │
  ├─ T=300ms: 启动批次 0 (2 个 goroutines)
  │
  ├─ T=350ms: 启动批次 1 (1 个 goroutine)
  │
  └─ 完成
  │
后台线程 2 (collectRemainingResponsesWithTimeout)
  │
  ├─ T=50ms: 开始收集
  │
  ├─ T=300-400ms: 收集 Staggered Tier 响应
  │
  ├─ T=400ms: 所有响应收集完成
  │  ├─ 合并去重
  │  ├─ 更新缓存
  │  └─ 完成
  │
  └─ 或 T=3000ms: 总超时，停止收集
```

## 9. 参数调优的影响

```
参数调整 → 流程变化

增加 activeTierSize (2 → 3)
  ├─ 第一阶段启动更多服务器
  ├─ 第一阶段成功率提高
  └─ 上游瞬时并发增加

减少 fallbackTimeout (300ms → 200ms)
  ├─ 更快启动第二阶段
  ├─ 用户感知延迟可能增加
  └─ 上游压力分散更快

增加 batchSize (2 → 3)
  ├─ 每批启动更多服务器
  ├─ 第二阶段完成更快
  └─ 上游瞬时并发增加

减少 staggerDelay (50ms → 30ms)
  ├─ 批次间隔更短
  ├─ 第二阶段完成更快
  └─ 上游压力波动更大

增加 totalCollectTimeout (3s → 5s)
  ├─ 后台补全时间更长
  ├─ 收集更完整的 IP
  └─ 缓存更新延迟增加
```

## 10. 监控指标

```
关键指标监控

第一阶段成功率
  ├─ 定义: (第一阶段成功的查询数) / (总查询数)
  ├─ 目标: > 80%
  └─ 低于目标: 增加 activeTierSize 或 fallbackTimeout

第二阶段启动率
  ├─ 定义: (启动第二阶段的查询数) / (总查询数)
  ├─ 目标: < 20%
  └─ 高于目标: 检查 Active Tier 服务器健康状态

后台补全收集率
  ├─ 定义: (后台补全收集的额外 IP 数) / (第一阶段 IP 数)
  ├─ 目标: > 50%
  └─ 低于目标: 增加 totalCollectTimeout

用户感知延迟
  ├─ 定义: (快速响应返回时间)
  ├─ 目标: < 100ms
  └─ 高于目标: 检查 Active Tier 服务器延迟

上游瞬时并发
  ├─ 定义: (单个时间窗口的最大并发数)
  ├─ 目标: < 原来的 50%
  └─ 高于目标: 减少 batchSize 或增加 staggerDelay
```

---

这些流程图详细展示了两阶段并行查询的各个方面，有助于理解系统的工作原理和调优方向。
