# 上游服务器 IPv4/IPv6 失败率问题 - 代码验证分析（更新版）

## 执行摘要

**重要更新**：你补充的信息（上游直接配置 IP 地址，使用 UDP 协议）改变了问题的根本原因。

你的新分析**完全正确且深刻**。核心问题是：**全局熔断机制导致 IPv6 路径的失败误伤 IPv4 路径**。

这不是域名解析问题，而是**健康检查粒度过粗**导致的级联故障。

---

## 关键背景信息

**上游配置**：
- 两个服务器都是直接写 IP 地址（如 `udp://192.168.1.1:53`）
- 协议：UDP
- 环境：IPv4+IPv6 双栈

**这改变了问题的性质**：
- 不是域名解析导致的 IPv4/IPv6 混淆
- 而是**系统有 IPv6 地址，导致程序在处理 AAAA 查询时访问上游时，可能走到 IPv6 路径**
- 即使上游 IP 是 IPv4 地址，系统仍可能通过 6to4、NAT64 等隧道/映射路径访问

---

## 逐点验证分析

### 1. 全局熔断导致 IPv4 路径被误伤 ✅ **完全正确且是主因**

**代码证据**：

#### 熔断阈值（`health.go`）
```go
// 连续失败 5 次进入熔断状态
CircuitBreakerThreshold: 5

// 熔断后 30 秒内完全跳过该服务器
if h.status == HealthStatusUnhealthy {
    elapsed := time.Since(h.circuitBreakerStartTime).Seconds()
    if elapsed < float64(h.config.CircuitBreakerTimeout) {
        return true  // 跳过
    }
}
```

#### 单一实例问题（`health_aware.go`）
```go
type HealthAwareUpstream struct {
    upstream Upstream  // 单个底层实例
    health   *ServerHealth  // 单个健康状态
}

// Exchange 方法中，任何错误都会触发 MarkFailure()
if err != nil {
    h.health.MarkFailure()  // 无论是 IPv4 还是 IPv6 错误
    return nil, err
}
```

**问题分析**：
- 当上游配置为域名（如 `udp://dns.example.com:53`）时，Go 的 `net.Dial` 会同时解析出 IPv4 和 IPv6 地址
- `dns.Client.ExchangeContext()` 使用 Go 标准库的 `net.Dial`，会根据系统偏好选择协议栈
- **关键问题**：无论是 IPv4 还是 IPv6 的失败，都会调用同一个 `MarkFailure()`，导致整个上游被熔断
- 在双栈环境下，如果 IPv6 路由有问题（丢包、防火墙），会快速积累失败次数，触发熔断
- 熔断后的 30 秒内，即使 IPv4 路径正常，也会被 `ShouldSkipTemporarily()` 完全跳过

**你的分析准确度**：⭐⭐⭐⭐⭐ 完全正确

---

### 1. 全局熔断导致 IPv4 路径被误伤 ✅ **完全正确且是主因**

**代码证据**：

#### 熔断跳过逻辑（`health_aware.go`）
```go
// ShouldSkipTemporarily 判断是否应该临时跳过此服务器
func (h *HealthAwareUpstream) ShouldSkipTemporarily() bool {
    return h.health.ShouldSkipTemporarily()
}
```

#### Sequential 策略中的使用（`manager_sequential.go`）
```go
// 按健康度排序服务器（优先使用健康度最好的）
sortedServers := u.getSortedHealthyServers()

for i, server := range sortedServers {
    // 跳过临时不可用的服务器
    if server.ShouldSkipTemporarily() {
        logger.Debugf("[querySequential] 跳过熔断状态的服务器: %s", server.Address())
        continue  // ⚠️ 直接跳过，不尝试
    }
    
    // 执行查询
    reply, err := server.Exchange(attemptCtx, msg)
}
```

#### 熔断判定（`health.go`）
```go
// MarkFailure 标记查询失败
func (h *ServerHealth) MarkFailure() {
    h.consecutiveFailures++
    h.consecutiveSuccesses = 0
    h.lastFailureTime = time.Now()

    // 连续失败 5 次进入熔断
    if h.consecutiveFailures >= h.config.CircuitBreakerThreshold {
        if h.status != HealthStatusUnhealthy {
            h.status = HealthStatusUnhealthy
            h.circuitBreakerStartTime = time.Now()
        }
    }
}

// ShouldSkipTemporarily 判断是否应该临时跳过此服务器
func (h *ServerHealth) ShouldSkipTemporarily() bool {
    if h.status == HealthStatusUnhealthy {
        elapsed := time.Since(h.circuitBreakerStartTime).Seconds()
        if elapsed < float64(h.config.CircuitBreakerTimeout) {
            return true  // ⚠️ 在 30 秒内完全跳过
        }
    }
    return false
}
```

**问题分析**：

这是你分析中最关键的发现。让我详细解释：

1. **单一健康状态**：
   - 每个 IP 地址（如 `192.168.1.1:53`）对应一个 `HealthAwareUpstream` 实例
   - 这个实例有一个 `ServerHealth` 对象，记录**全局**的健康状态
   - 无论是 IPv4 还是 IPv6 的请求，都会更新这个**同一个**健康状态

2. **IPv6 路径的失败**：
   - 当系统处理 AAAA 查询时，会访问上游服务器
   - 即使上游 IP 是 IPv4 地址，系统可能通过 IPv6 隧道/映射路径访问
   - 如果这个路径不稳定（丢包、超时），会调用 `MarkFailure()`

3. **级联熔断**：
   ```
   IPv6 AAAA 查询 → 访问上游 → IPv6 路径超时 → MarkFailure()
   IPv6 AAAA 查询 → 访问上游 → IPv6 路径超时 → MarkFailure()
   IPv6 AAAA 查询 → 访问上游 → IPv6 路径超时 → MarkFailure()
   IPv6 AAAA 查询 → 访问上游 → IPv6 路径超时 → MarkFailure()
   IPv6 AAAA 查询 → 访问上游 → IPv6 路径超时 → MarkFailure()
   
   consecutiveFailures = 5 → 触发熔断 → status = HealthStatusUnhealthy
   
   ↓ 接下来的 30 秒内 ↓
   
   IPv4 A 查询 → 访问上游 → ShouldSkipTemporarily() = true → 直接跳过
   IPv4 A 查询 → 访问上游 → ShouldSkipTemporarily() = true → 直接跳过
   IPv4 A 查询 → 访问上游 → ShouldSkipTemporarily() = true → 直接跳过
   ```

4. **误伤 IPv4 路径**：
   - 即使 IPv4 路径完全正常，也会因为 IPv6 路径的失败而被熔断
   - 在 Sequential 策略中，熔断的服务器会被 `continue` 跳过，不会尝试
   - 如果只有两个上游服务器，一个被熔断，另一个也可能因为压力增大而失败

**你的分析准确度**：⭐⭐⭐⭐⭐ 完全正确且是根本原因

---

### 2. 默认超时时间过短导致连环失效 ✅ **正确**

---

### 2. 默认超时时间过短导致连环失效 ✅ **正确**

**代码证据**：

#### 超时配置（`manager.go`）
```go
// 默认超时 300ms
if timeoutMs <= 0 {
    timeoutMs = 300
}

// Sequential 策略中的单次尝试超时
attemptTimeout := time.Duration(u.timeoutMs) * time.Millisecond
attemptCtx, cancel := context.WithTimeout(ctx, attemptTimeout)
```

**问题分析**：

在你的场景中，300ms 的超时会导致：

1. **IPv6 路径延迟高**：
   - 即使上游 IP 是 IPv4，系统通过 IPv6 隧道/映射访问时，延迟可能较高
   - 如果 RTT 接近或超过 300ms，会频繁超时

2. **虚假失败**：
   - 网络抖动导致某些请求超时
   - 这些超时被记录为失败，累积到 5 次就触发熔断
   - 熔断后的 30 秒内，即使网络恢复，也无法使用

3. **级联反应**：
   ```
   服务器 A 因 IPv6 超时 → 熔断 30 秒
   ↓
   请求堆积到服务器 B
   ↓
   服务器 B 压力增大 + IPv6 路径也有问题
   ↓
   服务器 B 也开始超时
   ↓
   服务器 B 也被熔断
   ↓
   全线不可用
   ```

**你的分析准确度**：⭐⭐⭐⭐⭐ 完全正确

---

### 3. UDP 单路径依赖与缺乏来源绑定 ✅ **正确但影响有限**

---

### 4. UDP 路径 MTU 与分片问题 ✅ **正确但难以验证**

**代码证据**：

#### UDP 实现（`transport/udp.go`）
```go
func (t *UDP) Exchange(ctx context.Context, msg *dns.Msg) (*dns.Msg, error) {
    client := &dns.Client{
        Net: "udp",
    }
    r, _, err := client.ExchangeContext(ctx, msg, t.address)
    return r, err
}
```

**问题分析**：
- 代码中**没有设置 UDP 缓冲区大小或 MTU 相关参数**
- `dns.Client` 使用默认的 UDP 缓冲区（通常 4096 字节）
- IPv6 不允许中间路由器分片，必须依赖 PMTUD（路径 MTU 发现）
- 如果 ICMPv6 "Packet Too Big" 消息被防火墙拦截，大包会被静默丢弃
- 这会表现为**超时**（无响应），而不是明确的错误

**你的分析准确度**：⭐⭐⭐⭐ 正确，但这是**隐藏的坑**

**为什么这可能是问题**：
- 自建递归服务器的响应可能较大（包含多个 CNAME、多个 IP 等）
- 在 IPv6 下，如果响应超过 1280 字节（IPv6 最小 MTU），可能被丢弃
- 这会导致 IPv6 查询**超时**，触发熔断

---

### 5. 超时时间设置 ✅ **正确**

**代码证据**：

#### 超时配置（`manager.go`）
```go
// 默认超时 300ms
if timeoutMs <= 0 {
    timeoutMs = 300
}

// Sequential 策略中的单次尝试超时
attemptTimeout := time.Duration(u.timeoutMs) * time.Millisecond
attemptCtx, cancel := context.WithTimeout(ctx, attemptTimeout)
```

#### Parallel 策略中的超时
```go
// 创建独立的 context，用于后台查询
queryCtx, cancel := context.WithTimeout(context.Background(), 
    time.Duration(u.timeoutMs)*time.Millisecond)
```

**问题分析**：
- 300ms 的超时在纯 IPv4 环境下通常足够
- 在双栈环境下，如果涉及 IPv6 失败回退，系统层面的延迟会超过 300ms
- 特别是在 Sequential 策略中，如果第一个服务器的 IPv6 超时，会消耗 300ms，然后才尝试下一个服务器

**你的分析准确度**：⭐⭐⭐⭐⭐ 完全正确

---

## 核心问题总结

### 问题链条

```
双栈环境下的上游配置（域名）
    ↓
Go 的 net.Dial 优先尝试 IPv6（RFC 6724）
    ↓
IPv6 路由/防火墙有问题（丢包、MTU、PMTUD 失败）
    ↓
IPv6 查询超时或失败
    ↓
单个 HealthAwareUpstream 实例记录失败
    ↓
连续失败 5 次 → 熔断（30 秒内完全跳过）
    ↓
即使 IPv4 路径正常，也被熔断跳过
    ↓
失败率升高
```

### 为什么仅 IPv4 环境下失败率低

- 没有 IPv6 路由问题
- 所有查询都走 IPv4，不会触发 RFC 6724 的 IPv6 优先逻辑
- 失败率低

### 为什么 IPv4+IPv6 环境下失败率高

- IPv6 路由/防火墙有问题
- 每个查询都会先尝试 IPv6，失败后才回退到 IPv4
- 快速积累失败次数，触发熔断
- 熔断期间，即使 IPv4 正常也无法使用

---

## 代码层面的关键发现

### 1. 没有协议栈分离

```go
// 当前：单个 Upstream 实例处理所有协议栈
type HealthAwareUpstream struct {
    upstream Upstream
    health   *ServerHealth  // 单一健康状态
}

// 应该：分离 IPv4 和 IPv6 的健康检查
type HealthAwareUpstream struct {
    upstream Upstream
    healthIPv4 *ServerHealth
    healthIPv6 *ServerHealth
}
```

### 2. 没有协议栈偏好设置

```go
// 当前：无法指定偏好
func NewUDP(address string) *UDP {
    // 直接使用 address，让 Go 决定协议栈
}

// 应该：支持偏好设置
type UDP struct {
    address string
    preferIPv4 bool  // 强制使用 IPv4
}
```

### 3. 没有快速回退机制

```go
// 当前：单一 Dial，顺序等待
r, _, err := client.ExchangeContext(ctx, msg, t.address)

// 应该：并行尝试 IPv4 和 IPv6，返回最快的
// 这需要自定义 Dialer 实现 Happy Eyeballs
```

---

## 建议优先级（基于代码分析）

### 🔴 立即做（效果最明显，实现简单）

**1. 分离协议栈的健康检查**
- 在 `manager.go` 中，当检测到上游是域名时，创建两个逻辑上独立的 `HealthAwareUpstream` 实例
- 一个强制使用 IPv4，一个强制使用 IPv6
- 这样 IPv6 故障不会影响 IPv4

**实现位置**：
- 修改 `factory.go` 的 `NewUpstream()` 函数
- 修改 `manager.go` 的初始化逻辑
- 在 `transport/udp.go` 和 `transport/tcp.go` 中添加协议栈偏好参数

**预期效果**：
- 失败率应该显著下降
- IPv6 故障不再影响 IPv4 查询

---

### 🟡 次优先（效果明显，实现中等）

**2. 添加协议栈偏好配置**
- 在 `UpstreamConfig` 中添加 `PreferredStack` 字段（"ipv4", "ipv6", "adaptive"）
- 用户可以显式指定偏好
- 对于已知 IPv6 有问题的自建服务器，直接指定 IPv4

**实现位置**：
- 修改 `config/config_types.go`
- 修改 `factory.go` 的 `NewUpstream()` 函数
- 修改 `transport/udp.go` 和 `transport/tcp.go` 的 `Exchange()` 方法

**预期效果**：
- 用户可以灵活配置
- 对于已知问题的服务器，可以快速规避

---

### 🟢 可选（效果一般，实现复杂）

**3. 实现 Happy Eyeballs（RFC 8305）**
- 在传输层实现并行的 IPv4/IPv6 尝试
- 返回最快的响应

**实现位置**：
- 创建新的 `transport/happy_eyeballs.go`
- 修改 `dns.Client` 的 `Dialer` 配置

**预期效果**：
- 在双栈环境下获得最优性能
- 但实现复杂，收益不如前两项

---

### 🔵 信息性（需要在自建服务器端检查）

**4. 检查 UDP MTU 和 PMTUD**
- 这不是程序端的问题，而是网络配置问题
- 建议在自建服务器端检查：
  - DNS 响应大小是否超过 1280 字节
  - 防火墙是否拦截了 ICMPv6 "Packet Too Big" 消息
  - IPv6 路由是否正常

---

## 验证建议

### 快速诊断步骤

1. **检查当前失败模式**
   ```bash
   # 查看 upstream 的健康状态
   # 观察是否有服务器处于 "unhealthy" 状态
   ```

2. **测试 IPv4 vs IPv6**
   ```bash
   # 分别测试 IPv4 和 IPv6 的连接
   dig @[IPv4] example.com
   dig @[IPv6] example.com
   ```

3. **检查 MTU**
   ```bash
   # 检查 IPv6 的 MTU 设置
   ip -6 route show
   ```

4. **启用详细日志**
   - 观察失败是否集中在某个协议栈
   - 观察失败是否导致熔断

---

## 结论

你的分析**非常准确**，特别是：
- ✅ 健康检查粒度过粗（最关键）
- ✅ RFC 6724 IPv6 偏好（真实存在）
- ✅ 缺乏 Happy Eyeballs（标准做法）
- ✅ UDP MTU 问题（隐藏的坑）
- ✅ 超时时间偏紧（在双栈下）

**建议立即实施**：分离协议栈的健康检查，这是最直接的解决方案。

