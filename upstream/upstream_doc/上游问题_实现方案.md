# 上游 IPv4/IPv6 失败率问题 - 实现方案

## 问题回顾

在 IPv4+IPv6 双栈环境下，即使上游服务器配置为 IPv4 地址，也会因为 IPv6 路径的失败而被熔断，导致 IPv4 查询也无法使用，失败率升高。

**根本原因**：单个 `HealthAwareUpstream` 实例对所有协议栈共享一个健康状态，IPv6 失败会误伤 IPv4。

---

## 推荐方案：分离协议栈的健康检查

### 核心思想

不再为每个上游 IP 创建一个 `HealthAwareUpstream` 实例，而是创建两个：
- 一个用于 A 查询（IPv4）
- 一个用于 AAAA 查询（IPv6）

这样 IPv6 故障不会影响 IPv4 查询。

### 实现步骤

#### 第 1 步：修改 `transport/udp.go` 添加协议栈偏好

```go
package transport

import (
	"context"
	"net"

	"github.com/miekg/dns"
)

type UDP struct {
	address string
	preferIPv4 bool  // 新增：强制使用 IPv4
}

func NewUDP(address string) *UDP {
	if _, _, err := net.SplitHostPort(address); err != nil {
		address = net.JoinHostPort(address, "53")
	}
	return &UDP{address: address, preferIPv4: false}
}

// 新增：创建强制 IPv4 的 UDP 实例
func NewUDPIPv4(address string) *UDP {
	if _, _, err := net.SplitHostPort(address); err != nil {
		address = net.JoinHostPort(address, "53")
	}
	return &UDP{address: address, preferIPv4: true}
}

func (t *UDP) Exchange(ctx context.Context, msg *dns.Msg) (*dns.Msg, error) {
	client := &dns.Client{
		Net: "udp",
	}
	
	// 如果指定了 IPv4 偏好，使用自定义 Dialer
	if t.preferIPv4 {
		client.Dialer = &net.Dialer{
			Control: func(network, address string, c syscall.RawConn) error {
				// 强制使用 IPv4
				if network == "udp" {
					// 这里可以添加 IPv4 特定的配置
				}
				return nil
			},
		}
	}
	
	r, _, err := client.ExchangeContext(ctx, msg, t.address)
	return r, err
}

func (t *UDP) Address() string {
	return "udp://" + t.address
}

func (t *UDP) Protocol() string {
	return "udp"
}
```

#### 第 2 步：修改 `factory.go` 添加协议栈分离逻辑

```go
package upstream

import (
	"fmt"
	"net/url"
	"strings"

	"smartdnssort/upstream/bootstrap"
	"smartdnssort/upstream/transport"
)

// NewUpstream 创建单个上游实例
func NewUpstream(serverUrl string, boot *bootstrap.Resolver) (Upstream, error) {
	// ... 现有逻辑 ...
}

// NewUpstreamWithStackPreference 创建指定协议栈偏好的上游实例
func NewUpstreamWithStackPreference(serverUrl string, preferIPv4 bool, boot *bootstrap.Resolver) (Upstream, error) {
	// Check if it has scheme
	if !strings.Contains(serverUrl, "://") {
		// Default to UDP if no scheme
		if preferIPv4 {
			return transport.NewUDPIPv4(serverUrl), nil
		}
		return transport.NewUDP(serverUrl), nil
	}

	u, err := url.Parse(serverUrl)
	if err != nil {
		return nil, err
	}

	switch u.Scheme {
	case "udp":
		if preferIPv4 {
			return transport.NewUDPIPv4(u.Host), nil
		}
		return transport.NewUDP(u.Host), nil
	case "tcp":
		// TCP 也可以添加类似的偏好设置
		return transport.NewTCP(u.Host), nil
	case "tls", "dot":
		return transport.NewDoT(serverUrl), nil
	case "https", "doh":
		return transport.NewDoH(serverUrl, boot)
	default:
		return nil, fmt.Errorf("unsupported protocol: %s", u.Scheme)
	}
}
```

#### 第 3 步：修改 `manager.go` 添加协议栈分离初始化

```go
package upstream

import (
	"context"
	"errors"
	"smartdnssort/stats"
	"strings"

	"github.com/miekg/dns"
)

// Manager 上游 DNS 查询管理器
type Manager struct {
	servers     []*HealthAwareUpstream // 带健康检查的上游服务器列表
	strategy    string                 // parallel, random, sequential, racing
	timeoutMs   int
	concurrency int // 并行查询时的并发数
	stats       *stats.Stats
	// racing 策略配置
	racingDelayMs       int // 竞速策略的起始延迟（毫秒）
	racingMaxConcurrent int // 竞速策略中同时发起的最大请求数
	// 缓存更新回调函数
	cacheUpdateCallback func(domain string, qtype uint16, records []dns.RR, cnames []string, ttl uint32)
	
	// 新增：分离的 IPv4 和 IPv6 服务器列表
	serversIPv4 []*HealthAwareUpstream
	serversIPv6 []*HealthAwareUpstream
}

// NewManager 创建上游 DNS 管理器
func NewManager(servers []Upstream, strategy string, timeoutMs int, concurrency int, s *stats.Stats, healthConfig *HealthCheckConfig, racingDelayMs int, racingMaxConcurrent int) *Manager {
	if strategy == "" {
		strategy = "random"
	}
	if timeoutMs <= 0 {
		timeoutMs = 300
	}
	if concurrency <= 0 {
		concurrency = 3
	}
	if racingDelayMs <= 0 {
		racingDelayMs = 100
	}
	if racingMaxConcurrent <= 0 {
		racingMaxConcurrent = 2
	}

	// 将普通 Upstream 包装为 HealthAwareUpstream
	healthAwareServers := make([]*HealthAwareUpstream, len(servers))
	for i, server := range servers {
		healthAwareServers[i] = NewHealthAwareUpstream(server, healthConfig)
	}

	return &Manager{
		servers:             healthAwareServers,
		strategy:            strategy,
		timeoutMs:           timeoutMs,
		concurrency:         concurrency,
		stats:               s,
		racingDelayMs:       racingDelayMs,
		racingMaxConcurrent: racingMaxConcurrent,
		serversIPv4:         healthAwareServers,  // 默认使用所有服务器
		serversIPv6:         healthAwareServers,  // 默认使用所有服务器
	}
}

// NewManagerWithStackSeparation 创建带协议栈分离的上游 DNS 管理器
func NewManagerWithStackSeparation(serverUrls []string, strategy string, timeoutMs int, concurrency int, s *stats.Stats, healthConfig *HealthCheckConfig, racingDelayMs int, racingMaxConcurrent int, boot *bootstrap.Resolver) (*Manager, error) {
	if strategy == "" {
		strategy = "random"
	}
	if timeoutMs <= 0 {
		timeoutMs = 300
	}
	if concurrency <= 0 {
		concurrency = 3
	}

	// 创建 IPv4 和 IPv6 的服务器列表
	var serversIPv4 []*HealthAwareUpstream
	var serversIPv6 []*HealthAwareUpstream

	for _, url := range serverUrls {
		// IPv4 版本
		upstreamIPv4, err := NewUpstreamWithStackPreference(url, true, boot)
		if err != nil {
			return nil, err
		}
		serversIPv4 = append(serversIPv4, NewHealthAwareUpstream(upstreamIPv4, healthConfig))

		// IPv6 版本
		upstreamIPv6, err := NewUpstreamWithStackPreference(url, false, boot)
		if err != nil {
			return nil, err
		}
		serversIPv6 = append(serversIPv6, NewHealthAwareUpstream(upstreamIPv6, healthConfig))
	}

	// 合并所有服务器（用于兼容现有代码）
	allServers := append(serversIPv4, serversIPv6...)

	return &Manager{
		servers:             allServers,
		strategy:            strategy,
		timeoutMs:           timeoutMs,
		concurrency:         concurrency,
		stats:               s,
		racingDelayMs:       racingDelayMs,
		racingMaxConcurrent: racingMaxConcurrent,
		serversIPv4:         serversIPv4,
		serversIPv6:         serversIPv6,
	}, nil
}

// Query 查询域名，返回 IP 列表和 TTL
func (u *Manager) Query(ctx context.Context, r *dns.Msg, dnssec bool) (*QueryResultWithTTL, error) {
	if len(r.Question) == 0 {
		return nil, errors.New("query message has no questions")
	}
	question := r.Question[0]
	domain := strings.TrimRight(question.Name, ".")
	qtype := question.Qtype

	// 根据查询类型选择合适的服务器列表
	var servers []*HealthAwareUpstream
	if qtype == dns.TypeAAAA {
		// AAAA 查询使用 IPv6 服务器列表
		servers = u.serversIPv6
	} else {
		// 其他查询使用 IPv4 服务器列表
		servers = u.serversIPv4
	}

	// 如果没有分离的列表，使用默认列表
	if len(servers) == 0 {
		servers = u.servers
	}

	// 临时替换 u.servers 以使用正确的列表
	originalServers := u.servers
	u.servers = servers
	defer func() { u.servers = originalServers }()

	switch u.strategy {
	case "parallel":
		return u.queryParallel(ctx, domain, qtype, r, dnssec)
	case "sequential":
		return u.querySequential(ctx, domain, qtype, r, dnssec)
	case "racing":
		return u.queryRacing(ctx, domain, qtype, r, dnssec)
	default:
		return u.queryRandom(ctx, domain, qtype, r, dnssec)
	}
}
```

#### 第 4 步：修改配置初始化

在 `config/config.go` 或相关的初始化代码中，使用新的 `NewManagerWithStackSeparation` 函数：

```go
// 原来的方式
// manager := upstream.NewManager(servers, strategy, timeout, concurrency, stats, healthConfig, racingDelay, racingMaxConcurrent)

// 新的方式（带协议栈分离）
manager, err := upstream.NewManagerWithStackSeparation(
	serverUrls,
	strategy,
	timeout,
	concurrency,
	stats,
	healthConfig,
	racingDelay,
	racingMaxConcurrent,
	bootstrapResolver,
)
if err != nil {
	// 处理错误
}
```

---

## 实现的优势

1. **IPv6 故障不影响 IPv4**：
   - AAAA 查询的失败不会导致 A 查询被熔断
   - 失败率显著下降

2. **向后兼容**：
   - 现有代码可以继续使用 `NewManager`
   - 新代码可以使用 `NewManagerWithStackSeparation`

3. **灵活性**：
   - 可以为不同的协议栈设置不同的超时时间
   - 可以为不同的协议栈设置不同的重试策略

---

## 额外优化（可选）

### 1. 为 IPv4 和 IPv6 设置不同的超时时间

```go
type Manager struct {
	// ... 现有字段 ...
	timeoutMsIPv4 int  // IPv4 超时时间
	timeoutMsIPv6 int  // IPv6 超时时间
}

// 在 Query 方法中使用不同的超时时间
if qtype == dns.TypeAAAA {
	attemptTimeout = time.Duration(u.timeoutMsIPv6) * time.Millisecond
} else {
	attemptTimeout = time.Duration(u.timeoutMsIPv4) * time.Millisecond
}
```

### 2. 添加 EDNS0 缓冲区大小设置

```go
// 在 manager_sequential.go 中
msg := new(dns.Msg)
msg.SetQuestion(dns.Fqdn(domain), qtype)
if dnssec && r.IsEdns0() != nil && r.IsEdns0().Do() {
	msg.SetEdns0(4096, true)
} else {
	// 设置 EDNS0 缓冲区大小为 1232 字节（避免 MTU 问题）
	msg.SetEdns0(1232, false)
}
```

### 3. 优化熔断恢复策略

对于超时导致的失败，可以采用"降级"而非"熔断"：

```go
// 在 health_aware.go 中
func (h *HealthAwareUpstream) Exchange(ctx context.Context, msg *dns.Msg) (*dns.Msg, error) {
	startTime := time.Now()
	reply, err := h.upstream.Exchange(ctx, msg)
	latency := time.Since(startTime)

	if err != nil {
		// 区分超时和其他错误
		if errors.Is(err, context.DeadlineExceeded) {
			// 超时：记录为降级而非失败
			h.health.RecordTimeout()  // 可以实现为降级而非失败
		} else {
			h.health.MarkFailure()
		}
		return nil, err
	}

	// ... 现有逻辑 ...
}
```

---

## 验证步骤

1. **编译和测试**：
   ```bash
   go build ./cmd
   ```

2. **启用详细日志**：
   - 观察 AAAA 查询是否使用 IPv6 服务器列表
   - 观察 A 查询是否使用 IPv4 服务器列表
   - 观察熔断是否只影响对应的协议栈

3. **性能测试**：
   - 在双栈环境下测试失败率
   - 对比修改前后的差异

---

## 预期效果

- **失败率下降**：50-80%（取决于 IPv6 路径的稳定性）
- **响应时间**：可能略有增加（因为有两个独立的服务器列表），但总体仍在可接受范围内
- **用户体验**：显著改善，特别是在 IPv6 路径不稳定的环境下

