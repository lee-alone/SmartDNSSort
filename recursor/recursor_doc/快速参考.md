# Recursor 前端集成快速参考

## 🚀 快速开始

### 前端修改（3 个文件）

#### 1. 修改 HTML 入口 ⚠️ 关键
**文件**：`webapi/web/index.html`
- 在 `js/modules/config.js` **之前** 引入 `js/modules/recursor.js`
- 确保加载顺序正确，否则 config.js 会报错

#### 2. 创建配置组件
**文件**：`webapi/web/components/config-recursor.html`
- 启用/禁用复选框
- 端口输入框
- 状态指示器
- 信息面板

#### 3. 创建管理模块
**文件**：`webapi/web/js/modules/recursor.js`
- `getRecursorStatus()` - 获取状态
- `updateRecursorStatus()` - 更新 UI
- `startRecursorStatusPolling()` - 启动轮询

### 后端修改（4 个文件）

#### 1. 配置类型
**文件**：`config/config_types.go`
```go
EnableRecursor bool `yaml:"enable_recursor,omitempty" json:"enable_recursor"`
RecursorPort   int  `yaml:"recursor_port,omitempty" json:"recursor_port"`
```

#### 2. 配置默认值
**文件**：`config/config_defaults.go`
```go
if cfg.Upstream.RecursorPort == 0 {
    cfg.Upstream.RecursorPort = 5353
}
```

#### 3. API 端点
**文件**：`webapi/api_recursor.go`（新建）
```go
func (api *API) GetRecursorStatus(c *gin.Context) {
    // 返回 RecursorStatus JSON
}
```

#### 4. 生命周期管理
**文件**：`dnsserver/server_init.go`、`server_lifecycle.go`
```go
// 初始化
if cfg.Upstream.EnableRecursor {
    server.recursorMgr = recursor.NewManager(cfg.Upstream.RecursorPort)
}

// 启动
if s.recursorMgr != nil {
    s.recursorMgr.Start()
}

// 停止
if s.recursorMgr != nil {
    s.recursorMgr.Stop()
}
```

---

## 📊 数据流

```
前端表单
  ↓ POST /api/config
后端保存配置
  ↓
初始化/重启 Recursor Manager
  ↓
启动 Unbound 进程
  ↓
前端轮询 GET /api/recursor/status
  ↓
更新状态指示器
```

---

## 🎨 UI 状态

| 状态 | 颜色 | 文本 |
|------|------|------|
| 运行中 | 🟢 | Running on port 5353 (Uptime: 2h 15m) |
| 已停止 | 🔴 | Stopped |
| 未知 | ⚫ | Unknown |

---

## 🌐 i18n 键

```javascript
config.recursor.legend              // "Recursive Resolver"
config.recursor.enable              // "Enable Embedded Unbound Recursor"
config.recursor.port                // "Recursor Port"
config.recursor.status              // "Status"
config.recursor.statusRunning       // "Running on port {{port}} (Uptime: {{uptime}})"
config.recursor.statusStopped       // "Stopped"
config.recursor.statusUnknown       // "Unknown"
config.recursor.info                // "Information"
config.recursor.infoVersion         // "Version: Unbound 1.24.2"
config.recursor.infoArch            // "Architecture: x86-64 (Linux & Windows)"
config.recursor.infoFeatures        // "Features: DNSSEC validation, caching, prefetching"
config.recursor.infoNote            // "Note: Recursor runs as a separate process on localhost"
```

---

## ⚠️ 关键风险提示

### 默认端口 5353 的 mDNS 冲突风险

**问题**：5353 是 mDNS (Multicast DNS) 的标准端口

**风险**：
- Windows/macOS 上 Bonjour 或其他 mDNS 服务可能占用此端口
- 导致 Recursor 启动失败或端口绑定错误

**建议**：
- 将默认端口改为 **8053**（更安全）
- 或在 UI 中添加警告提示
- 或两者结合

---

## 🔌 API 端点

### 获取状态
```
GET /api/recursor/status

响应：
{
  "enabled": true,
  "port": 5353,
  "address": "127.0.0.1:5353",
  "uptime": 7200,
  "last_health_check": 1706700000
}
```

### 保存配置
```
POST /api/config

请求体包含：
{
  "upstream": {
    "enable_recursor": true,
    "recursor_port": 5353,
    ...
  }
}
```

---

## ⚡ 轮询机制

```javascript
// 每 5 秒更新一次
setInterval(updateRecursorStatus, 5000);

// 或在用户操作后立即更新
document.getElementById('configForm').addEventListener('submit', () => {
    setTimeout(updateRecursorStatus, 1000);
});
```

---

## ✅ 验证清单

### 前端
- [ ] 配置表单显示正确
- [ ] 状态指示器实时更新
- [ ] 启用/禁用功能正常
- [ ] 多语言显示正确
- [ ] 错误提示显示正确

### 后端
- [ ] 配置保存/加载正确
- [ ] API 端点返回正确数据
- [ ] Recursor 启动/停止正常
- [ ] 端口冲突检查工作
- [ ] 日志记录完整

### 集成
- [ ] 端到端流程正常
- [ ] 状态同步及时
- [ ] 错误处理完善
- [ ] 性能满足要求

---

## 🐛 常见问题

### Q: 为什么状态显示 "Unknown"？
A: 可能是 API 请求失败或后端未初始化。检查浏览器控制台错误。

### Q: 端口 5353 被占用怎么办？
A: 修改 `recursor_port` 为其他端口（如 5354）。

### Q: Recursor 启动失败怎么办？
A: 检查日志，可能是二进制文件缺失或权限不足。

### Q: 如何禁用 Recursor？
A: 取消勾选 "Enable Embedded Unbound Recursor" 并保存。

---

## 📚 详细文档

- **前端修改细节**：`recursor/前端修改细节.md`
- **前端集成总结**：`recursor/前端集成总结.md`
- **Recursor 开发指南**：`recursor/DEVELOPMENT_GUIDE.md`

---

**最后更新**：2026-01-31
